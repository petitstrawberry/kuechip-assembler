/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/web.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/instruction.ts":
/*!****************************!*\
  !*** ./lib/instruction.ts ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/parser */ \"./lib/parser.ts\");\n/* harmony import */ var _lib_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/util */ \"./lib/util.ts\");\n/* harmony import */ var _lib_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/logger */ \"./lib/logger.ts\");\n\n\n\nvar MNEMONIC_MAP = {\n    LD: 0x60, ST: 0x70, SBC: 0x80, ADC: 0x90, SUB: 0xA0,\n    ADD: 0xB0, EOR: 0xC0, OR: 0xD0, AND: 0xE0, CMP: 0xF0,\n};\nvar Instruction = /** @class */ (function () {\n    /**\n     * @param content - アセンブリ命令 (1行) の内容\n     */\n    function Instruction(content) {\n        this._raw = content;\n        this.parse();\n    }\n    // getter\n    Instruction.prototype.raw = function () { return this._raw; };\n    Instruction.prototype.label = function () { return this._label; };\n    Instruction.prototype.mnemonic = function () { return this._mnemonic; };\n    Instruction.prototype.op1 = function () { return this._op1; };\n    // getter/setter\n    Instruction.prototype.previousLineLabel = function (value) {\n        if (value == null) {\n            return this._previousLineLabel;\n        } // getter\n        else {\n            this._previousLineLabel = value;\n        } // setter\n    };\n    /**\n     * 命令行 (ニーモニックのある行) かチェックする\n     * @returns ある: true, ない: false\n     */\n    Instruction.prototype.hasMnemonic = function () {\n        return (this._mnemonic != null);\n    };\n    /**\n     * アセンブリ命令にオペランドが 1 つあるかどうかをチェックする\n     * @returns ある: true, ない: false\n     */\n    Instruction.prototype.hasOneOperand = function () {\n        return (this._op1 != null);\n    };\n    /**\n     * アセンブリ命令にオペランドが 2 つあるかどうかをチェックする\n     * @returns ある: true, ない: false\n     */\n    Instruction.prototype.hasTwoOperands = function () {\n        return (this._op1 !== null && this._op2 != null);\n    };\n    /**\n     * パースして各トークンを記録\n     */\n    Instruction.prototype.parse = function () {\n        var result = (new _lib_parser__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this._raw)).parse();\n        this._label = result.label ? result.label.toUpperCase() : undefined;\n        this._mnemonic = result.mnemonic ? result.mnemonic.toUpperCase() : undefined;\n        this._op1 = result.op1 ? result.op1.toUpperCase() : undefined;\n        this._op2 = result.op2 ? result.op2.toUpperCase() : undefined;\n        this._comment = result.comment ? result.comment.toUpperCase() : undefined;\n    };\n    /**\n     * アセンブルしてオペコード/オペランドのフィールドにセットする.\n     * ラベルで評価できないなら _isSkipped をセットする.\n     * @param params - パラメータのオブジェクト\n     * @returns アドレスのインクリメントサイズオブジェクト\n     */\n    Instruction.prototype.assemble = function (params) {\n        var result = { curAddrInc: 0, locAddrInc: 0 };\n        var mnemonic = this.mnemonic();\n        if (mnemonic == null) {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"internal error: calling to assemble() of 'Instruction' object without mnemonic.\");\n        }\n        if (mnemonic.match(/^EQU$/)) { /* do nothing */ }\n        else if (mnemonic.match(/^LOC$/)) { /* do nothing */ }\n        else if (mnemonic.match(/^DAT$/)) {\n            this.assembleDat(params);\n        }\n        else if (mnemonic.match(/^PROG$/)) {\n            this.assembleProg(params);\n        }\n        else if (mnemonic.match(/^LD$/)) {\n            this.assembleLd(params);\n        }\n        else if (mnemonic.match(/^(ST|SBC|ADC)$/)) {\n            this.assembleStSbcAdc(params);\n        }\n        else if (mnemonic.match(/^SUB$/)) {\n            this.assembleSub(params);\n        }\n        else if (mnemonic.match(/^ADD$/)) {\n            this.assembleAdd(params);\n        }\n        else if (mnemonic.match(/^(EOR|OR|AND|CMP)$/)) {\n            this.assembleEorOrAndCmp(params);\n        }\n        else if (mnemonic.match(/^B/)) {\n            this.assembleB(params);\n        }\n        else if (mnemonic.match(/^NOP$/)) {\n            this.assembleNop(params);\n        }\n        else if (mnemonic.match(/^HLT$/)) {\n            this.assembleHlt(params);\n        }\n        else if (mnemonic.match(/^RCF$/)) {\n            this.assembleRcf(params);\n        }\n        else if (mnemonic.match(/^SCF$/)) {\n            this.assembleScf(params);\n        }\n        else if (mnemonic.match(/^END$/)) { /* do nothing */ }\n        else if (mnemonic.match(/^INC$/)) {\n            this.assembleInc(params);\n        }\n        else if (mnemonic.match(/^DEC$/)) {\n            this.assembleDec(params);\n        }\n        else if (mnemonic.match(/^PSH$/)) {\n            this.assemblePsh(params);\n        }\n        else if (mnemonic.match(/^POP$/)) {\n            this.assemblePop(params);\n        }\n        else if (mnemonic.match(/^CAL$/)) {\n            this.assembleCal(params);\n        }\n        else if (mnemonic.match(/^RET$/)) {\n            this.assembleRet(params);\n        }\n        else if (mnemonic.match(/^[SR][RL][AL]$/)) {\n            this.assembleShiftRotate(params);\n        }\n        else if (mnemonic.match(/^OUT$/)) {\n            this.assembleOut(params);\n        }\n        else if (mnemonic.match(/^IN$/)) {\n            this.assembleIn(params);\n        }\n        else {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Invalid mnemonic '\" + this.mnemonic() + \".\");\n        }\n        if (this.mnemonic() === 'DAT') {\n            result.locAddrInc++;\n        }\n        // DAT 命令以外の順番にアドレスを振る命令の場合\n        else {\n            if (params.onlyAddrAlloc) {\n                this._addr = params.curAddr; // 配置アドレスを確定\n            }\n            if (this._requireAddrWidth == null) {\n                throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"internal error: this._requireAddrWidth is not defined\");\n            }\n            // 次の配置アドレスを決定\n            result.curAddrInc++; // アドレスインクリメント回数を増加\n            if (this._operand != null) {\n                result.curAddrInc++; // アドレスインクリメント回数を増加\n            }\n            result.curAddrInc = this._requireAddrWidth;\n            _lib_logger__WEBPACK_IMPORTED_MODULE_2__[\"default\"].debug(\"Increase addr \" + result.curAddrInc + \" unit(s).\");\n        }\n        return result;\n    };\n    /**\n     * 代入演算と算術演算のオペコードを取得 (規則配列のもの)\n     * @param params - assemble() された時のパラメータ\n     * @returns {opcode?: number, operand?: number | string}\n     */\n    Instruction.prototype.getOpcodeOfAssignmentAndArithmeticInst = function (params) {\n        if (this.mnemonic() == null) {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"internal error: calling getOpcodeOfAssignmentAndArithmeticInst() of 'Instruction' object without mnemonic.\");\n        }\n        if (!this.hasTwoOperands()) {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Expected 2 operands for \" + this.mnemonic());\n        }\n        // チェック済みなので強制的に string として OK\n        var mnemonic = this._mnemonic;\n        var op1 = this._op1;\n        var op2 = this._op2;\n        var baseOpcode = MNEMONIC_MAP[mnemonic]; // 命令表の行を決定\n        if (baseOpcode == null) {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Internal error: invalid mnemonic \" + mnemonic);\n        }\n        var res = {};\n        // op1\n        if (op1 === 'ACC') {\n            res.opcode = baseOpcode + 0;\n        }\n        else if (op1 === 'IX') {\n            res.opcode = baseOpcode + 8;\n        }\n        else {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Invalid operand '\" + op1 + \"' for \" + mnemonic);\n        }\n        // op2 == ACC\n        if (op2 === 'ACC') {\n            if (mnemonic.match(/^ST/)) {\n                throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Invalid operand '\" + op2 + \"' of 'ST' (use 'LD' to set registers)\");\n            }\n            if (params.onlyAddrAlloc) {\n                return { requireAddrWidth: 1 };\n            }\n            res.opcode += 0;\n        }\n        // op2 == IX\n        else if (op2 === 'IX') {\n            if (mnemonic.match(/^ST/)) {\n                throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Invalid operand '\" + op2 + \"' of 'ST' (use 'LD' to set registers)\");\n            }\n            if (params.onlyAddrAlloc) {\n                return { requireAddrWidth: 1 };\n            }\n            res.opcode += 1;\n        }\n        // op2 == d (ラベルを含む)\n        else if (op2.match(/^([A-Z0-9_\\+\\-\\*\\/]+)$/i)) {\n            if (mnemonic.match(/^ST/)) {\n                throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Invalid operand '\" + op2 + \"' of 'ST' (use 'LD' to set registers)\");\n            }\n            if (params.onlyAddrAlloc) {\n                return { requireAddrWidth: 2 };\n            }\n            res.opcode += 2;\n            res.operand = _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].evalExpression(op2, params.labels);\n            if (!_lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isNumber(res.operand)) {\n                _lib_logger__WEBPACK_IMPORTED_MODULE_2__[\"default\"].debug(\"Operand \" + res.operand + \" cannot be evaluated now. skip.\");\n            }\n        }\n        // op2 = [sp+d]\n        else if (op2.match(/\\[SP(\\+.+)?\\]$/i)) {\n            if (params.onlyAddrAlloc) {\n                return { requireAddrWidth: 2 };\n            }\n            res.opcode += 3;\n            var offset = RegExp.$1;\n            if (offset != null && offset.trim().length > 0) {\n                res.operand = _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].evalExpression(offset, params.labels);\n            }\n            else {\n                res.operand = 0;\n            }\n        }\n        // op2 = [IX+d] / [IX]\n        else if (op2.match(/^\\[IX(\\+.+)?\\]$/i)) {\n            if (params.onlyAddrAlloc) {\n                return { requireAddrWidth: 2 };\n            }\n            res.opcode += 6;\n            var offset = RegExp.$1;\n            if (offset != null && offset.trim().length > 0) {\n                res.operand = _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].evalExpression(offset, params.labels);\n            }\n            else {\n                res.operand = 0;\n            }\n        }\n        // op2 = [d]                         # d : decimal, hex or label\n        else if (op2.match(/^\\[([A-Z0-9_\\+\\-\\*\\/]+)\\]$/i)) {\n            if (params.onlyAddrAlloc) {\n                return { requireAddrWidth: 2 };\n            }\n            res.opcode += 4;\n            res.operand = _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].evalExpression(op2.replace(/[\\[\\]]/g, ''), params.labels);\n            if (!_lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isNumber(res.operand)) {\n                _lib_logger__WEBPACK_IMPORTED_MODULE_2__[\"default\"].debug(\"Operand \" + res.operand + \" cannot be evaluated now. skip.\");\n            }\n        }\n        // op2 = (IX+d) / (IX) (only for kuechip2)\n        else if (op2.match(/^\\(IX(\\+.+)?\\)$/i)) {\n            if (params.onlyAddrAlloc) {\n                return { requireAddrWidth: 2 };\n            }\n            res.opcode += 7;\n            var offset = RegExp.$1;\n            if (offset != null && offset.trim().length > 0) {\n                res.operand = _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].evalExpression(offset, params.labels);\n            }\n            else {\n                res.operand = 0;\n            }\n        }\n        // op2 = (d) (only for kuechip2)     # d : decimal, hex or label\n        else if (op2.match(/^\\((.*)\\)$/)) {\n            if (params.onlyAddrAlloc) {\n                return { requireAddrWidth: 2 };\n            }\n            res.opcode += 5;\n            var offset = RegExp.$1;\n            if (offset != null && offset.trim().length > 0) {\n                res.operand = _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].evalExpression(offset, params.labels);\n            }\n            else {\n                res.operand = 0;\n            }\n        }\n        else {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Invalid operand '\" + op1 + \"/\" + op2 + \"'\");\n        }\n        return res;\n    };\n    /**\n     * DAT のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     * @todo 分類としては疑似命令になるので kueasm.ts に移したい\n     */\n    Instruction.prototype.assembleDat = function (params) {\n        if (params.onlyAddrAlloc) {\n            this._addr = params.locAddr;\n            return;\n        }\n        if (!this.hasOneOperand()) {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Expected 1 operand for \" + this.mnemonic());\n        }\n        if (params.locAddr == null) {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error('Address for LOC is not defined.');\n        }\n        var op1 = this._op1; // hasOneOperand でチェックしてるので string 扱いして OK\n        this._opcode = _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].evalExpression(op1, params.labels);\n    };\n    /**\n     * PROG のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    Instruction.prototype.assembleProg = function (params) {\n        throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"'PROG' is not supported\");\n    };\n    /**\n     * LD のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    Instruction.prototype.assembleLd = function (params) {\n        if (!this.hasTwoOperands()) {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Expected 2 operands for \" + this._mnemonic);\n        }\n        var op1 = this._op1;\n        var op2 = this._op2;\n        // LD IX SP\n        if (op1 === 'IX' && op2 === 'SP') {\n            if (params.onlyAddrAlloc) {\n                this._requireAddrWidth = 1;\n                return;\n            }\n            this._opcode = 0x01;\n        }\n        // LD SP IX\n        else if (op1 === 'SP' && op2 === 'IX') {\n            if (params.onlyAddrAlloc) {\n                this._requireAddrWidth = 1;\n                return;\n            }\n            this._opcode = 0x03;\n        }\n        // LD SP d\n        else if (op1 === 'SP') {\n            if (params.onlyAddrAlloc) {\n                this._requireAddrWidth = 2;\n                return;\n            }\n            this._opcode = 0x02;\n            this._operand = _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].evalExpression(op2, params.labels);\n        }\n        // その他の (規則的な割り当てになっている) 命令\n        else {\n            var res = this.getOpcodeOfAssignmentAndArithmeticInst(params);\n            if (params.onlyAddrAlloc) {\n                this._requireAddrWidth = res.requireAddrWidth;\n                return;\n            }\n            if (res.opcode != null) {\n                this._opcode = res.opcode;\n            }\n            if (res.operand != null) {\n                this._operand = res.operand;\n            }\n        }\n    };\n    /**\n     * ST/SBC/ADC のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    Instruction.prototype.assembleStSbcAdc = function (params) {\n        if (!this.hasTwoOperands()) {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Expected 2 operands for \" + this._mnemonic);\n        }\n        var res = this.getOpcodeOfAssignmentAndArithmeticInst(params);\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = res.requireAddrWidth;\n            return;\n        }\n        if (res.opcode != null) {\n            this._opcode = res.opcode;\n        }\n        if (res.operand != null) {\n            this._operand = res.operand;\n        }\n    };\n    /**\n     * SUB のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    Instruction.prototype.assembleSub = function (params) {\n        if (!this.hasTwoOperands()) {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Expected 2 operands for \" + this._mnemonic);\n        }\n        var op1 = this._op1;\n        var op2 = this._op2;\n        if (op1 === 'SP') {\n            if (params.onlyAddrAlloc) {\n                this._requireAddrWidth = 2;\n                return;\n            }\n            this._opcode = 0x07;\n            this._operand = _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].evalExpression(op2, params.labels);\n        }\n        else {\n            var res = this.getOpcodeOfAssignmentAndArithmeticInst(params);\n            if (params.onlyAddrAlloc) {\n                this._requireAddrWidth = res.requireAddrWidth;\n                return;\n            }\n            if (res.opcode != null) {\n                this._opcode = res.opcode;\n            }\n            if (res.operand != null) {\n                this._operand = res.operand;\n            }\n        }\n    };\n    /**\n     * ADD のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    Instruction.prototype.assembleAdd = function (params) {\n        if (!this.hasTwoOperands()) {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Expected 2 operands for \" + this._mnemonic);\n        }\n        var op1 = this._op1;\n        var op2 = this._op2;\n        if (op1 === 'SP') {\n            if (params.onlyAddrAlloc) {\n                this._requireAddrWidth = 2;\n                return;\n            }\n            this._opcode = 0x06;\n            this._operand = _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].evalExpression(op2, params.labels);\n        }\n        else {\n            var res = this.getOpcodeOfAssignmentAndArithmeticInst(params);\n            if (params.onlyAddrAlloc) {\n                this._requireAddrWidth = res.requireAddrWidth;\n                return;\n            }\n            if (res.opcode != null) {\n                this._opcode = res.opcode;\n            }\n            if (res.operand != null) {\n                this._operand = res.operand;\n            }\n        }\n    };\n    /**\n     * EOR/OR/CMP のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    Instruction.prototype.assembleEorOrAndCmp = function (params) {\n        if (!this.hasTwoOperands()) {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Expected 2 operands for \" + this._mnemonic);\n        }\n        var op1 = this._op1;\n        var op2 = this._op2;\n        var res = this.getOpcodeOfAssignmentAndArithmeticInst(params);\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = res.requireAddrWidth;\n            return;\n        }\n        if (res.opcode != null) {\n            this._opcode = res.opcode;\n        }\n        if (res.operand != null) {\n            this._operand = res.operand;\n        }\n    };\n    /**\n     * B のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    Instruction.prototype.assembleB = function (params) {\n        if (!this.hasOneOperand()) {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Expected 1 operand for \" + this._mnemonic);\n        }\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 2;\n            return;\n        }\n        if (this._mnemonic === 'BA') {\n            this._opcode = 0x30;\n        }\n        else if (this._mnemonic === 'BVF') {\n            this._opcode = 0x38;\n        }\n        else if (this._mnemonic === 'BNZ') {\n            this._opcode = 0x31;\n        }\n        else if (this._mnemonic === 'BZP') {\n            this._opcode = 0x32;\n        }\n        else if (this._mnemonic === 'BP') {\n            this._opcode = 0x33;\n        }\n        else if (this._mnemonic === 'BNI') {\n            this._opcode = 0x34;\n        }\n        else if (this._mnemonic === 'BNC') {\n            this._opcode = 0x35;\n        }\n        else if (this._mnemonic === 'BGE') {\n            this._opcode = 0x36;\n        }\n        else if (this._mnemonic === 'BGT') {\n            this._opcode = 0x37;\n        }\n        else if (this._mnemonic === 'BZN') {\n            this._opcode = 0x3B;\n        }\n        else if (this._mnemonic === 'BNO') {\n            this._opcode = 0x3C;\n        }\n        else if (this._mnemonic === 'BZ') {\n            this._opcode = 0x39;\n        }\n        else if (this._mnemonic === 'BN') {\n            this._opcode = 0x3A;\n        }\n        else if (this._mnemonic === 'BC') {\n            this._opcode = 0x3D;\n        }\n        else if (this._mnemonic === 'BLT') {\n            this._opcode = 0x3E;\n        }\n        else if (this._mnemonic === 'BLE') {\n            this._opcode = 0x3F;\n        }\n        else {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Invalid mnemonic '\" + this._mnemonic + \"'\");\n        }\n        var op1 = this._op1;\n        this._operand = _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].evalExpression(op1, params.labels);\n    };\n    /**\n     * NOP のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    Instruction.prototype.assembleNop = function (params) {\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        this._opcode = 0x00;\n    };\n    /**\n     * HLT のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    Instruction.prototype.assembleHlt = function (params) {\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        this._opcode = 0x0F;\n    };\n    /**\n     * RCF のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    Instruction.prototype.assembleRcf = function (params) {\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        this._opcode = 0x20;\n    };\n    /**\n     * SCF のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    Instruction.prototype.assembleScf = function (params) {\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        this._opcode = 0x28;\n    };\n    /**\n     * INC のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    Instruction.prototype.assembleInc = function (params) {\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        if (this._op1 !== 'SP') {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Invalid operand for \" + this._mnemonic + \": \" + this._op1);\n        }\n        this._opcode = 0x04;\n    };\n    /**\n     * DEC のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    Instruction.prototype.assembleDec = function (params) {\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        if (this._op1 !== 'SP') {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Invalid operand for \" + this._mnemonic + \": \" + this._op1);\n        }\n        this._opcode = 0x05;\n    };\n    /**\n     * PSH のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    Instruction.prototype.assemblePsh = function (params) {\n        if (!this.hasOneOperand()) {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Expected 1 operand for \" + this._mnemonic);\n        }\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        if (this._op1 === 'ACC') {\n            this._opcode = 0x08;\n        }\n        else if (this._op1 === 'IX') {\n            this._opcode = 0x09;\n        }\n        else {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"invalid operand '\" + this._op1 + \"' for \" + this._mnemonic);\n        }\n    };\n    /**\n     * POP のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    Instruction.prototype.assemblePop = function (params) {\n        if (!this.hasOneOperand()) {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Expected 1 operand for \" + this._mnemonic);\n        }\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        if (this._op1 === 'ACC') {\n            this._opcode = 0x0A;\n        }\n        else if (this._op1 === 'IX') {\n            this._opcode = 0x0B;\n        }\n        else {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"invalid operand '\" + this._op1 + \"' for \" + this._mnemonic);\n        }\n    };\n    /**\n     * CAL のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    Instruction.prototype.assembleCal = function (params) {\n        if (!this.hasOneOperand()) {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Expected 1 operand for \" + this._mnemonic);\n        }\n        var op1 = this._op1;\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 2;\n            return;\n        }\n        this._opcode = 0x0C;\n        this._operand = _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].evalExpression(op1, params.labels);\n    };\n    /**\n     * RET のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    Instruction.prototype.assembleRet = function (params) {\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        this._opcode = 0x0D;\n    };\n    /**\n     * shift/rotate 系命令のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    Instruction.prototype.assembleShiftRotate = function (params) {\n        if (!this.hasOneOperand()) {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Expected 1 operand for \" + this._mnemonic);\n        }\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        if (this._mnemonic === 'SRA') {\n            this._opcode = 0x40;\n        }\n        else if (this._mnemonic === 'SLA') {\n            this._opcode = 0x41;\n        }\n        else if (this._mnemonic === 'SRL') {\n            this._opcode = 0x42;\n        }\n        else if (this._mnemonic === 'SLL') {\n            this._opcode = 0x43;\n        }\n        else if (this._mnemonic === 'RRA') {\n            this._opcode = 0x44;\n        }\n        else if (this._mnemonic === 'RLA') {\n            this._opcode = 0x45;\n        }\n        else if (this._mnemonic === 'RRL') {\n            this._opcode = 0x46;\n        }\n        else if (this._mnemonic === 'RLL') {\n            this._opcode = 0x47;\n        }\n        else {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Invalid mnemonic: \" + this._mnemonic);\n        }\n        if (this._op1 === 'ACC') {\n            this._opcode += 0;\n        }\n        else if (this._op1 === 'IX') {\n            this._opcode += 8;\n        }\n        else {\n            throw _lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].error(\"Invalid operand for \" + this._mnemonic + \": \" + this._op1);\n        }\n    };\n    /**\n     * OUT のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    Instruction.prototype.assembleOut = function (params) {\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        this._opcode = 0x10;\n    };\n    /**\n     * IN のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    Instruction.prototype.assembleIn = function (params) {\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        this._opcode = 0x1F;\n    };\n    /**\n     * ST のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    Instruction.prototype.assembleSt = function (params) {\n        _lib_logger__WEBPACK_IMPORTED_MODULE_2__[\"default\"].error('not implemented');\n    };\n    /**\n     * バイナリ表現のプログラムデータの生成 (内部形式から出力用形式に整形)\n     */\n    Instruction.prototype.generate = function (addrUnitBytes) {\n        var addr = this._addr != null ? (_lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].dec2hex(this._addr, 2 * addrUnitBytes, '') + ':') : '';\n        var opcode = this._opcode != null ? (_lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].dec2hex(this._opcode, 2 * addrUnitBytes, '')) : '';\n        var operand = this._operand != null ? (_lib_util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].dec2hex(this._operand, 2 * addrUnitBytes, '')) : '';\n        var comment = this._raw !== '' ? \" \" + this._raw : '';\n        var binary = (addr + \" \" + opcode + \" \" + operand).padEnd(17, ' ') + (\"#\" + comment);\n        _lib_logger__WEBPACK_IMPORTED_MODULE_2__[\"default\"].debug(binary);\n        return binary;\n    };\n    return Instruction;\n}());\n/* harmony default export */ __webpack_exports__[\"default\"] = (Instruction);\n\n\n//# sourceURL=webpack:///./lib/instruction.ts?");

/***/ }),

/***/ "./lib/kueasm.ts":
/*!***********************!*\
  !*** ./lib/kueasm.ts ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/logger */ \"./lib/logger.ts\");\n/* harmony import */ var _lib_instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/instruction */ \"./lib/instruction.ts\");\n/* harmony import */ var _lib_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/util */ \"./lib/util.ts\");\n\n\n\nvar Kueasm = /** @class */ (function () {\n    /**\n     * @param asm - アセンブリプログラムの内容\n     * @param mode - 'kuechip2' or 'kuechip3'\n     * @param logLebel - ログレベル (デフォルトは warn. debug や trace で詳細ログを確認可能)\n     */\n    function Kueasm(asm, mode, logLevel) {\n        if (logLevel === void 0) { logLevel = 'warn'; }\n        this._labels = {}; // ラベルのアドレス (10進数) の対応\n        this._currentAddr = 0; // メモリデータを配置するアドレス\n        this._locAddr = undefined; // LOC (DAT で値を配置するアドレス) (for kue3)\n        this._isEnded = false; // end 命令が見つかった\n        this._mode = mode;\n        this._addrUnitBytes = (mode === 'kuechip3') ? 2 : 1;\n        _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setLogLevel(logLevel);\n        _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].info('Start parse');\n        try {\n            this._instructions = asm.split('\\n').map(function (content) { return new _lib_instruction__WEBPACK_IMPORTED_MODULE_1__[\"default\"](content); });\n        }\n        catch (_a) {\n            _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error('Failed to parse assembly program');\n            return;\n        }\n    }\n    /**\n     * アセンブルする\n     * @returns アセンブル結果 (バイナリ表現)\n     */\n    Kueasm.prototype.exec = function () {\n        _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].info('Start assemble');\n        // logger.trace(this._instructions)\n        if (!this.assemble()) {\n            _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error('Failed to convert binary data');\n            return;\n        }\n        return this.generate();\n    };\n    /**\n     * バイナリ表現を生成して binary にセット\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.assemble = function () {\n        _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].debug('1st pass');\n        // logger.trace(this._instructions)          // デバッグ用に内部データをダンプ\n        for (var idx = 0; idx < this._instructions.length; idx++) {\n            _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setLineNumber(idx + 1); // ロガーに現在の処理行をセット\n            // logger.trace(idx + 1)\n            // logger.trace(this._instructions)          // デバッグ用に内部データをダンプ\n            var inst = this._instructions[idx];\n            // 空行はスキップ\n            if (inst.raw().trim() === '') {\n                continue;\n            }\n            if (inst.mnemonic() != null && this._multilineLabel != null) {\n                inst.previousLineLabel(this._multilineLabel);\n                this._multilineLabel = undefined;\n            }\n            // 疑似命令の処理\n            // - EQU, その他のラベル行の処理\n            if (inst.mnemonic() === 'EQU') {\n                this.processEqu(inst);\n            }\n            else {\n                var label = inst.label() || inst.previousLineLabel();\n                if (label != null) {\n                    if (inst.mnemonic() != null) { // 命令がある行ならラベルに行番号をバインド\n                        this._labels[label] = this._currentAddr;\n                    }\n                    else { // 命令が無い行なら (次の命令行にバインドするために) 記録しておく\n                        this._multilineLabel = inst.label();\n                    }\n                }\n            }\n            // - LOC の処理\n            if (inst.mnemonic() === 'LOC') {\n                this.processLoc(inst);\n            }\n            // 命令行でなければ次へ\n            if (inst.mnemonic() == null\n                || inst.mnemonic() === 'EQU'\n                || inst.mnemonic() === 'LOC'\n                || inst.mnemonic() === 'END') {\n                continue;\n            }\n            _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].debug(\"Process \" + inst.mnemonic() + \".\");\n            // バイナリ表現への変換\n            var _a = inst.assemble({\n                labels: this._labels,\n                curAddr: this._currentAddr,\n                locAddr: this._locAddr,\n                onlyAddrAlloc: true,\n            }), curAddrInc = _a.curAddrInc, locAddrInc = _a.locAddrInc;\n            // 次の配置命令アドレスを算出\n            this._currentAddr += (curAddrInc * this._addrUnitBytes);\n            if (this._locAddr != null) {\n                this._locAddr += (locAddrInc * this._addrUnitBytes);\n            }\n        }\n        _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setLineNumber(undefined);\n        _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].debug('2nd pass');\n        for (var idx = 0; idx < this._instructions.length; idx++) {\n            var inst = this._instructions[idx];\n            _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setLineNumber(idx + 1); // ロガーに現在の処理行をセット\n            // logger.trace(this.instructions)          // デバッグ用に内部データをダンプ\n            // 空行はスキップ\n            if (inst.raw().trim() === '') {\n                continue;\n            }\n            // - END の処理\n            if (inst.mnemonic() === 'END') {\n                break;\n            }\n            // 命令行でなければ次へ\n            if (inst.mnemonic() == null\n                || inst.mnemonic() === 'EQU'\n                || inst.mnemonic() === 'LOC') {\n                continue;\n            }\n            _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].debug(\"Process \" + inst.mnemonic() + \".\");\n            // バイナリ表現への変換\n            var _b = inst.assemble({\n                labels: this._labels,\n                curAddr: this._currentAddr,\n                locAddr: this._locAddr,\n                onlyAddrAlloc: false,\n            }), curAddrInc = _b.curAddrInc, locAddrInc = _b.locAddrInc;\n        }\n        _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setLineNumber(undefined);\n        return true;\n    };\n    /**\n     * EQU の処理 (10 進数変換してラベル表 labels に追加)\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processEqu = function (inst) {\n        var label = inst.label() || inst.previousLineLabel();\n        var op1 = inst.op1();\n        if (label == null) {\n            _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error('Label not found for EQU');\n            return false;\n        }\n        if (op1 == null) {\n            _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error('Expected 1 operand for EQU');\n            return false;\n        }\n        if (op1.toUpperCase() === 'CA') {\n            // EQU のオペランドを CA (current address) にしたら,\n            // その EQU 疑似命令の存在する場所のアドレスが割り当てられる.\n            // アドレスのインクリメントは行わない\n            this._labels[label] = this._currentAddr;\n        }\n        else {\n            _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].debug(this._labels);\n            var value = _lib_util__WEBPACK_IMPORTED_MODULE_2__[\"default\"].evalExpression(op1, this._labels);\n            this._labels[label] = value;\n        }\n        _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].trace('labels: ' + JSON.stringify(this._labels));\n        return true;\n    };\n    /**\n     * LOC のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processLoc = function (inst) {\n        var op1 = inst.op1();\n        if (op1 == null) {\n            _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error('Expected 1 operand for LOC');\n            return false;\n        }\n        var addr = _lib_util__WEBPACK_IMPORTED_MODULE_2__[\"default\"].evalExpression(op1, this._labels);\n        if (_lib_util__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isNumber(addr)) {\n            this._locAddr = addr;\n        }\n        _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].trace(\"LOC addr: \" + this._locAddr);\n        return true;\n    };\n    /**\n     * 出力用バイナリを生成\n     * @returns 出力用バイナリ\n     */\n    Kueasm.prototype.generate = function () {\n        var _this = this;\n        return this._instructions.map(function (inst) { return inst.generate(_this._addrUnitBytes); }).join('\\n') + '\\n';\n    };\n    return Kueasm;\n}());\n/* harmony default export */ __webpack_exports__[\"default\"] = (Kueasm);\n\n\n//# sourceURL=webpack:///./lib/kueasm.ts?");

/***/ }),

/***/ "./lib/logger.ts":
/*!***********************!*\
  !*** ./lib/logger.ts ***!
  \***********************/
/*! exports provided: KueasmLogger, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KueasmLogger\", function() { return KueasmLogger; });\n// ---------- CLI 用 ----------\n// import log4js, {Log4js, Logger} from 'log4js'\n// export class KueasmLogger {\n//   private _log4jsLogger: Logger\n//   private _lineNumber:   number | undefined // ログに出力するアセンブリの行番号\n//   constructor(logLevel: string = 'debug') {\n//     this._log4jsLogger = log4js.getLogger()\n//     this._log4jsLogger.level = logLevel\n//     // if ( logLevel ) { this.log4jsLogger.level = logLevel }\n//     // else            { this.log4jsLogger.level = 'debug'  }\n//   }\n//   // setter\n//   public setLineNumber(lineNumber: number | undefined) {\n//     this._lineNumber = lineNumber\n//   }\n//   public setLogLevel(logLevel: string) {\n//     this._log4jsLogger.level = logLevel\n//   }\n//   // log\n//   public trace(msg: any) { this._log4jsLogger.trace(msg, this.getLineNumberInfo()) }\n//   public debug(msg: any) { this._log4jsLogger.debug(msg, this.getLineNumberInfo()) }\n//   public info(msg: any)  { this._log4jsLogger.info (msg, this.getLineNumberInfo()) }\n//   public warn(msg: any)  { this._log4jsLogger.warn (msg, this.getLineNumberInfo()) }\n//   public error(msg: any) { this._log4jsLogger.error(msg, this.getLineNumberInfo()) }\n//   private getLineNumberInfo() {\n//     return this._lineNumber == null ? '' : ` (l.${this._lineNumber})`\n//   }\n// }\n// ---------- web 用 ----------\nvar LEVEL_TRACE = 0;\nvar LEVEL_DEBUG = 1;\nvar LEVEL_INFO = 2;\nvar LEVEL_WARN = 3;\nvar LEVEL_ERROR = 4;\nvar LEVEL_FATAL = 5;\nvar KueasmLogger = /** @class */ (function () {\n    function KueasmLogger(logLevel) {\n        if (logLevel === void 0) { logLevel = 'debug'; }\n        this._logLevel = LEVEL_INFO;\n        this.setLogLevel(logLevel);\n    }\n    // setter\n    KueasmLogger.prototype.setLineNumber = function (lineNumber) {\n        this._lineNumber = lineNumber;\n    };\n    KueasmLogger.prototype.setLogLevel = function (logLevel) {\n        this._logLevel = logLevel === 'fatal' ? LEVEL_FATAL\n            : logLevel === 'error' ? LEVEL_ERROR\n                : logLevel === 'warn' ? LEVEL_WARN\n                    : logLevel === 'info' ? LEVEL_INFO\n                        : logLevel === 'debug' ? LEVEL_DEBUG\n                            : logLevel === 'trace' ? LEVEL_TRACE\n                                : LEVEL_INFO;\n    };\n    KueasmLogger.prototype.trace = function (msg) {\n        if (this._logLevel <= LEVEL_TRACE) {\n            eval(\"logger.trace(msg, ' (l.'+this._lineNumber+')')\");\n        }\n    };\n    KueasmLogger.prototype.debug = function (msg) {\n        if (this._logLevel <= LEVEL_DEBUG) {\n            eval(\"logger.debug(msg, ' (l.'+this._lineNumber+')')\");\n        }\n    };\n    KueasmLogger.prototype.info = function (msg) {\n        if (this._logLevel <= LEVEL_INFO) {\n            eval(\"logger.info(msg,  ' (l.'+this._lineNumber+')')\");\n        }\n    };\n    KueasmLogger.prototype.warn = function (msg) {\n        if (this._logLevel <= LEVEL_WARN) {\n            eval(\"logger.warn(msg,  ' (l.'+this._lineNumber+')')\");\n        }\n    };\n    KueasmLogger.prototype.error = function (msg) {\n        if (this._logLevel <= LEVEL_ERROR) {\n            eval(\"logger.error(msg, ' (l.'+this._lineNumber+')')\");\n        }\n    };\n    KueasmLogger.prototype.fatal = function (msg) {\n        if (this._logLevel <= LEVEL_FATAL) {\n            eval(\"logger.fatal(msg, ' (l.'+this._lineNumber+')')\");\n        }\n    };\n    return KueasmLogger;\n}());\n\n// ---------- 共通 ----------\nvar logger = new KueasmLogger('warn');\n/* harmony default export */ __webpack_exports__[\"default\"] = (logger);\n\n\n//# sourceURL=webpack:///./lib/logger.ts?");

/***/ }),

/***/ "./lib/parser.ts":
/*!***********************!*\
  !*** ./lib/parser.ts ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar Parser = /** @class */ (function () {\n    /**\n     * アセンブリプログラムをパースする\n     * @param パースしたい命令 (1 行)\n     */\n    function Parser(content) {\n        this._buf = content;\n    }\n    /**\n     * アセンブリプログラムをパースする\n     * @returns パース済み Instruction オブジェクト\n     * @throws パースに失敗\n     */\n    Parser.prototype.parse = function () {\n        if (!this.parseComment()) {\n            throw new Error('Parse error');\n        }\n        if (!this.parseLabel()) {\n            throw new Error('Parse error');\n        }\n        if (!this.parseMnemonicAndOperands()) {\n            throw new Error('Parse error');\n        }\n        return {\n            label: this._label,\n            mnemonic: this._mnemonic,\n            op1: this._op1,\n            op2: this._op2,\n            comment: this._comment,\n        };\n    };\n    /**\n     * コメントの処理する\n     * @returns 成功: true, 失敗: false\n     */\n    Parser.prototype.parseComment = function () {\n        // '*', '#', ';;', '//' 以降をコメントとして扱う\n        var regexComment = /(\\*|#|;;|\\/\\/)(?<comment>.*)$/;\n        var match = this._buf.match(regexComment);\n        if (match) {\n            this._comment = match.groups.comment; // コメントを記録しておく\n            this._buf = this._buf.replace(regexComment, '').trim(); // コメントを除去\n        }\n        return true;\n    };\n    /**\n     * ラベルの処理する\n     * @returns 成功: true, 失敗: false\n     */\n    Parser.prototype.parseLabel = function () {\n        var regexLabel = /^(?<label>[A-za-z0-9_]+)\\s*:/;\n        var match = this._buf.match(regexLabel);\n        if (match) {\n            this._label = match.groups.label; // ラベルを記録しておく\n            this._buf = this._buf.replace(regexLabel, '').trim(); // ラベルを除去\n        }\n        return true;\n    };\n    /**\n     * ニーモニック, オペランドの処理\n     * @returns 成功: true, 失敗: false\n     */\n    Parser.prototype.parseMnemonicAndOperands = function () {\n        var tokens = this._buf.trim().split(/ +/);\n        // 最初の空白まで\n        if (tokens.length > 0) {\n            this._mnemonic = tokens.shift();\n        }\n        // 2 引数の場合は第 1 オペランドの後ろにコンマがあるかもしれない\n        if (tokens.length > 0) {\n            this._op1 = tokens.shift().replace(/,$/, '');\n        }\n        // 第 2 オペランドはスペースを含む可能性があるので残りを join\n        if (tokens.length > 0) {\n            this._op2 = tokens.join(' ');\n        }\n        return true;\n    };\n    return Parser;\n}());\n/* harmony default export */ __webpack_exports__[\"default\"] = (Parser);\n\n\n//# sourceURL=webpack:///./lib/parser.ts?");

/***/ }),

/***/ "./lib/util.ts":
/*!*********************!*\
  !*** ./lib/util.ts ***!
  \*********************/
/*! exports provided: Util, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Util\", function() { return Util; });\n/* harmony import */ var _lib_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/logger */ \"./lib/logger.ts\");\n\nvar Util = /** @class */ (function () {\n    function Util() {\n    }\n    /**\n     * 数値かどうか (string も数字として判定)\n     * @param value - 判定したい値\n     * @returns boolean\n     */\n    Util.prototype.isNumber = function (value) {\n        if (typeof value === 'number') {\n            return isFinite(value);\n        }\n        else if (typeof value === 'string') {\n            // 末尾の H/h は 16 進数なので除外して数値か判定\n            return !isNaN(Number(value.replace(/h$/i, '')));\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * パディング済み 16 進数文字列にして返す\n     * @param num - 数値 (10進数)\n     * @returns パディング済み 16 進数文字列\n     */\n    Util.prototype.dec2hex = function (num, digit, prefix) {\n        if (prefix === void 0) { prefix = '0x'; }\n        if (num < 0) {\n            num = num & 0xFFFF;\n        } // 補数表現\n        return prefix + num.toString(16).toUpperCase().padStart(digit, '0');\n    };\n    /**\n     * 式を評価 (四則演算, ラベルを含めることができる)\n     * @param expression - 評価したい式\n     * @returns パディング付き 16 進数表現\n     */\n    Util.prototype.evalExpression = function (expression, labels) {\n        if (expression.match(/[\\+|\\-|\\*|\\/]/)) {\n            var terms = expression.split(/\\s*([\\+|\\-|\\*|\\/])\\s*/); // 各項を切り出す\n            var formattedTerms = [];\n            for (var _i = 0, terms_1 = terms; _i < terms_1.length; _i++) {\n                var term = terms_1[_i];\n                // 空白なら何もしない\n                if (term === '') { /* do nothing */ }\n                // 四則演算子はそのまま\n                else if (term === '+' || term === '-' || term === '*' || term === '/') {\n                    formattedTerms.push(term);\n                }\n                else {\n                    var value = this.evalExpression(term, labels);\n                    _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].trace(\"Evaluate term: \" + term + \" \\u2192 \" + value);\n                    formattedTerms.push(value);\n                }\n            }\n            // この時点でラベルの評価は完了している\n            // (一部が評価できない場合は再帰呼び出しした evalExpression で例外が投げられる)\n            var expressionValue = eval(formattedTerms.join(''));\n            _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].trace(\"Evaluate expression: \" + formattedTerms.join('') + \" \\u2192 \" + expressionValue);\n            return expressionValue;\n        }\n        // 16 進数\n        else if (expression.match(/^[0-9A-F]+H$/i)) {\n            return parseInt(expression.replace(/h/i, ''), 16);\n        }\n        // 10 進数\n        else if (util.isNumber(expression)) {\n            return parseInt(expression); // そのまま\n        }\n        // label\n        else if (labels[expression] != null) {\n            return labels[expression];\n        }\n        else {\n            throw util.error(\"'\" + expression + \"' cannot evaluate.\");\n            // return `$(${expression})` // $(expression) にしておいて遅延評価する\n            // → 2pass にして遅延評価しないように変更\n        }\n    };\n    /**\n     * エラーメッセージを logger.error() してから Error オブジェクトを返す\n     * @param string - エラーメッセージ\n     * @returns Error オブジェクト\n     */\n    Util.prototype.error = function (msg) {\n        _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error(msg);\n        return new Error(msg);\n    };\n    return Util;\n}());\n\nvar util = new Util();\n/* harmony default export */ __webpack_exports__[\"default\"] = (util);\n\n\n//# sourceURL=webpack:///./lib/util.ts?");

/***/ }),

/***/ "./src/web.ts":
/*!********************!*\
  !*** ./src/web.ts ***!
  \********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_kueasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/kueasm */ \"./lib/kueasm.ts\");\n\n// シミュレータ (kuesim.js) のロガーを使う\nvar mylogger = {\n    debug: function (msg) { return eval(\"logger.debug(\\\"\" + msg + \"\\\")\"); },\n    info: function (msg) { return eval(\"logger.info(\\\"\" + msg + \"\\\")\"); },\n    warn: function (msg) { return eval(\"logger.warn(\\\"\" + msg + \"\\\")\"); },\n    error: function (msg) { return eval(\"logger.error(\\\"\" + msg + \"\\\")\"); },\n};\nfunction assemble() {\n    var asm = $('#input-assembly').val();\n    if (asm == null) {\n        mylogger.error('internal error: failed to get instructions');\n        return;\n    }\n    var bin = (new _lib_kueasm__WEBPACK_IMPORTED_MODULE_0__[\"default\"](asm, 'kuechip3', 'debug')).exec();\n    if (!bin) {\n        // logger.log.error('failed to assemble')\n        return;\n    }\n    console.log(bin);\n    $('#output-binary').val(bin);\n}\n// アセンブルボタン (ts 側のコードを叩くのでこちらでイベントを設定しておく)\n$('#btn-assemble').on('click', assemble);\n\n\n//# sourceURL=webpack:///./src/web.ts?");

/***/ })

/******/ });