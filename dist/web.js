/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/web.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/kueasm.ts":
/*!***********************!*\
  !*** ./lib/kueasm.ts ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/logger */ \"./lib/logger.ts\");\n\nvar MNEMONIC_MAP = {\n    LD: 0x60, ST: 0x70, SBC: 0x80, ADC: 0x90, SUB: 0xA0,\n    ADD: 0xB0, EOR: 0xC0, OR: 0xD0, AND: 0xE0, CMP: 0xF0,\n};\nvar Kueasm = /** @class */ (function () {\n    /**\n     * @param asmFilePath - アセンブリファイルへのパス\n     * @param mode - 'kuechip2' or 'kuechip3'\n     */\n    function Kueasm(asm, mode, logLevel) {\n        if (logLevel === void 0) { logLevel = 'warn'; }\n        this._labels = {}; // ラベルのアドレス (10進数) の対応\n        this._currentAddr = 0; // メモリデータを配置するアドレス\n        this._currentLineNumber = 0; // 現在処理している行番号\n        this._currentLineContent = ''; // 現在処理している行の内容\n        this._isEnded = false; // end 命令が見つかった\n        this._asm = asm.split('\\n').map(function (content, index) { return ({ raw: content, lineNumber: index }); });\n        this._mode = mode;\n        this._addrUnitBytes = (mode === 'kuechip3') ? 2 : 1;\n        this.log = new _lib_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this, logLevel);\n    }\n    /**\n     * アセンブルする\n     * @returns アセンブル結果 (バイナリ表現)\n     */\n    Kueasm.prototype.exec = function () {\n        this.log.info('Start assemble');\n        this.log.debug(this._asm);\n        this.log.info('Start parse');\n        if (!this.parse()) {\n            this.log.error('Failed to parse assembly program');\n            return;\n        }\n        this.log.info('Start process');\n        if (!this.process()) {\n            this.log.error('Failed to convert binary data');\n            return;\n        }\n        this.log.info('Start generate');\n        if (!this.generate()) {\n            this.log.error('Failed to generate binary');\n            return;\n        }\n        if (!this._isEnded) {\n            this.log.warn(\"'END' instruction is not found\");\n        }\n        return this._binary;\n    };\n    /**\n     * アセンブリプログラムをパースする\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.parse = function () {\n        for (var _i = 0, _a = this._asm; _i < _a.length; _i++) {\n            var asmLine = _a[_i];\n            var buf = asmLine.raw.trim();\n            buf = this.parseComment(asmLine, buf);\n            buf = this.parseLabel(asmLine, buf);\n            this.parseMnemonicAndOperands(asmLine, buf);\n        }\n        // this.log.debug(this._asm)\n        return true;\n    };\n    /**\n     * コメントを処理する\n     * @param asmLine - AsmLine オブジェクト\n     * @param buf - 行をパース途中の残りテキスト\n     * @returns パースした残り\n     */\n    Kueasm.prototype.parseComment = function (asmLine, buf) {\n        // コメントの処理 ('*', '#', ';;', '//' 以降)\n        var regexComment = /(\\*|#|;;|\\/\\/)(?<comment>.*)$/;\n        var match = buf.match(regexComment);\n        if (match) {\n            asmLine.comment = match.groups.comment; // コメントを記録しておく\n            return buf.replace(regexComment, '').trim(); // コメントを除去\n        }\n        return buf;\n    };\n    /**\n     * ラベルを処理する\n     * @param asmLine - AsmLine オブジェクト\n     * @param buf - 行をパース途中の残りテキスト\n     * @returns パースした残り\n     */\n    Kueasm.prototype.parseLabel = function (asmLine, buf) {\n        // ラベルの処理\n        var regexLabel = /^(?<label>[A-za-z0-9_]+)\\s*:/;\n        var match = buf.match(regexLabel);\n        if (match) {\n            asmLine.label = match.groups.label; // ラベルを記録しておく\n            return buf.replace(regexLabel, '').trim(); // ラベルを除去\n        }\n        return buf;\n    };\n    /**\n     * ラベルを処理する\n     * @param asmLine - AsmLine オブジェクト\n     * @param buf - 行をパース途中の残りテキスト\n     * @returns パースした残り\n     */\n    Kueasm.prototype.parseMnemonicAndOperands = function (asmLine, buf) {\n        // ニーモニック, オペランドの処理\n        var tokens = buf.split(/ +/);\n        if (tokens.length > 0) {\n            asmLine.mnemonic = tokens.shift();\n        }\n        if (tokens.length > 0) {\n            asmLine.op1 = tokens.shift().replace(/,$/, '');\n        }\n        if (tokens.length > 0) {\n            asmLine.op2 = tokens.join(' ');\n        }\n    };\n    /**\n     * バイナリ表現を生成して _binary にセット\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.process = function () {\n        for (var _i = 0, _a = this._asm; _i < _a.length; _i++) {\n            var asmLine = _a[_i];\n            // this.log.debug(this._asm)                    // デバッグ用に内部データをダンプ\n            this._currentLineNumber = asmLine.lineNumber; // ログ用に現在の処理行を表示\n            if (asmLine.raw.trim() === '') {\n                continue;\n            }\n            if (asmLine.label) {\n                this._labels[asmLine.label] = this._currentAddr;\n            }\n            this.log.debug(\"Process \" + asmLine.mnemonic);\n            if (!asmLine.mnemonic) {\n                continue;\n            }\n            var mnemonic = asmLine.mnemonic.toUpperCase();\n            if (mnemonic.match(/^EQU$/)) {\n                if (!this.processEqu(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^LOC$/)) {\n                if (!this.processLoc(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^DAT$/)) {\n                if (!this.processDat(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^PROG$/)) {\n                if (!this.processProg(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^LD$/)) {\n                if (!this.processLd(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^(ST|SBC|ADC)$/)) {\n                if (!this.processStSbcAdc(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^SUB$/)) {\n                if (!this.processSub(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^ADD$/)) {\n                if (!this.processAdd(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^(EOR|OR|AND|CMP)$/)) {\n                if (!this.processEorOrAndCmp(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^B/)) {\n                if (!this.processB(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^NOP$/)) {\n                if (!this.processNop(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^HLT$/)) {\n                if (!this.processHlt(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^RCF$/)) {\n                if (!this.processRcf(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^SCF$/)) {\n                if (!this.processScf(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^END$/)) {\n                if (!this.processEnd(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^INC$/)) {\n                if (!this.processInc(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^DEC$/)) {\n                if (!this.processDec(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^PSH$/)) {\n                if (!this.processPsh(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^POP$/)) {\n                if (!this.processPop(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^CAL$/)) {\n                if (!this.processCal(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^RET$/)) {\n                if (!this.processRet(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^[SR][RL]/)) {\n                if (!this.processSrRl(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^OUT$/)) {\n                if (!this.processOut(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^IN$/)) {\n                if (!this.processIn(asmLine)) {\n                    return false;\n                }\n            }\n            else if (mnemonic.match(/^ST/)) {\n                if (!this.processSt(asmLine)) {\n                    return false;\n                }\n            }\n            else {\n                this.log.error(\"Invalid mnemonic '\" + mnemonic);\n                return false;\n            }\n            if (asmLine.opcode != null) {\n                // DAT 命令以外の順番にアドレスを振る命令の処理\n                if (!asmLine.addr) {\n                    asmLine.addr = this._currentAddr;\n                    this._currentAddr += this._addrUnitBytes;\n                    this.log.debug('Increment addr');\n                }\n            }\n            if (asmLine.operand != null) {\n                this._currentAddr += this._addrUnitBytes;\n                this.log.debug('Increment addr');\n            }\n        }\n        return true;\n    };\n    /**\n     * 数値かどうか (string も数字として判定)\n     * @param value - 判定したい値\n     * @returns boolean\n     */\n    Kueasm.prototype.isNumber = function (value) {\n        if (typeof value === 'number') {\n            return isFinite(value);\n        }\n        else if (typeof value === 'string') {\n            return !isNaN(Number(value));\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * 式を評価 (四則演算, ラベルを含めることができる)\n     * @param expression - 評価したい式\n     * @returns パディング付き 16 進数表現\n     */\n    Kueasm.prototype.evalExpression = function (expression) {\n        if (expression.match(/[\\+|\\-|\\*|\\/]/)) {\n            var terms = expression.split(/\\s*([\\+|\\-|\\*|\\/])\\s*/); // 各項を切り出す\n            var formattedTerms = [];\n            for (var _i = 0, terms_1 = terms; _i < terms_1.length; _i++) {\n                var term = terms_1[_i];\n                // 空白なら何もしない\n                if (term === '') { }\n                // 四則演算子はそのまま\n                else if (term === '+' || term === '-' || term === '*' || term === '/') {\n                    formattedTerms.push(term);\n                }\n                else {\n                    var value_1 = this.evalExpression(term);\n                    this.log.debug(\"Evaluate term: \" + term + \" \\u2192 \" + value_1);\n                    // 評価できない項があれば式ごと遅延評価に回す\n                    if (!this.isNumber(value_1)) {\n                        this.log.debug(\"Expression '\" + term + \"' in '\" + expression + \"' cannot be evaluated now. \"\n                            + \"It will be evaluated later\");\n                        return \"$(\" + expression + \")\";\n                    }\n                    formattedTerms.push(value_1);\n                }\n            }\n            // 全項評価できる値なら式全体も評価する\n            var value = eval(formattedTerms.join(''));\n            this.log.debug(\"Evaluate expression: \" + formattedTerms.join('') + \" \\u2192 \" + value);\n            return value;\n        }\n        // 16 進数\n        else if (expression.match(/^[0-9A-F]+H$/i)) {\n            return parseInt(expression.replace(/h/i, ''), 16);\n        }\n        // 10 進数\n        else if (this.isNumber(expression)) {\n            return parseInt(expression); // そのまま\n        }\n        // label\n        else if (this._labels[expression]) {\n            return this._labels[expression];\n        }\n        else {\n            return \"$(\" + expression + \")\"; // $(expression) にしておいて遅延評価する\n        }\n    };\n    /**\n     * パディング済み 16 進数文字列にして返す\n     * @param num - 数値 (10進数)\n     * @returns パディング済み 16 進数文字列\n     */\n    Kueasm.prototype.dec2hex = function (num, prefix) {\n        if (prefix === void 0) { prefix = '0x'; }\n        if (num < 0) {\n            num = num & (this._addrUnitBytes & 0xFFFF);\n        } // 補数表現\n        return prefix + num.toString(16).toUpperCase().padStart(this._addrUnitBytes * 2, '0');\n    };\n    /**\n     * 代入演算と算術演算のオペコードを取得 (規則配列のもの)\n     * @param mnemonic - ニーモニック\n     * @param op1 - 第 1 オペランド\n     * @param op2 - 第 2 オペランド\n     * @returns {opcode?: number, operand?: number | string, error?: boolean}\n     */\n    Kueasm.prototype.getOpcodeOfAssignmentAndArithmeticInst = function (mnemonic, op1, op2) {\n        mnemonic = mnemonic.toUpperCase();\n        op1 = op1.toUpperCase();\n        op2 = op2.toUpperCase();\n        var baseOpcode = MNEMONIC_MAP[mnemonic]; // 命令表の行を決定\n        if (!baseOpcode) {\n            this.log.error(\"Internal error: invalid mnemonic \" + mnemonic);\n            return { error: true };\n        }\n        var res = {};\n        // op1\n        if (op1 === 'ACC') {\n            res.opcode = baseOpcode + 0;\n        }\n        else if (op1 === 'IX') {\n            res.opcode = baseOpcode + 8;\n        }\n        else {\n            this.log.error(\"Invalid operand '\" + op1 + \"' for \" + mnemonic);\n            return { error: true };\n        }\n        // op2 == ACC\n        if (op2 === 'ACC') {\n            if (mnemonic.match(/^ST/)) {\n                this.log.error(\"Invalid operand '\" + op2 + \"' of 'ST' (use 'LD' to set registers)\");\n                return { error: true };\n            }\n            res.opcode += 0;\n        }\n        // op2 == IX\n        else if (op2 === 'IX') {\n            if (mnemonic.match(/^ST/)) {\n                this.log.error(\"Invalid operand '\" + op2 + \"' of 'ST' (use 'LD' to set registers)\");\n                return { error: true };\n            }\n            res.opcode += 1;\n        }\n        // op2 == d (ラベルを含む)\n        else if (op2.match(/^([A-Z0-9_\\+\\-\\*\\/]+)$/)) {\n            if (mnemonic.match(/^ST/)) {\n                this.log.error(\"Invalid operand '\" + op2 + \"' of 'ST' (use 'LD' to set registers)\");\n                return { error: true };\n            }\n            res.opcode += 2;\n            res.operand = this.evalExpression(op2);\n            if (!this.isNumber(res.operand)) {\n                this.log.debug(\"Operand \" + res.operand + \" cannot be evaluated now. skip.\");\n            }\n        }\n        // # op2 = [sp+d]\n        // elsif ($op2 =~ /\\[(SP|sp)\\+*([\\w\\+\\-]*)\\]/) {\n        //   $opcode += 3;\n        //   $operand = parse_expression($2);\n        // }\n        // # op2 = [IX+d] / [IX]\n        // elsif ($op2 =~ /\\[(IX|ix)\\+*([\\w\\+\\-]*)\\]/) {\n        //   $opcode += 6;\n        //   $operand = parse_expression($2);\n        // }\n        // op2 = [d]                         # d : decimal, hex or label\n        else if (op2.match(/^\\[([A-Z0-9_\\+\\-\\*\\/]+)\\]$/)) {\n            res.opcode += 4;\n            res.operand = this.evalExpression(op2.replace(/[\\[\\]]/g, ''));\n            if (!this.isNumber(res.operand)) {\n                this.log.debug(\"Operand \" + res.operand + \" cannot be evaluated now. skip.\");\n            }\n        }\n        // # op2 = (IX+d) / (IX) (only for kuechip2)\n        // elsif ($op2 =~ /\\((IX|ix)\\+*([\\w\\+\\-]*)\\)/) {\n        //   $opcode += 7;\n        //   $operand = parse_expression($2);\n        // }\n        // # op2 = (d) (only for kuechip2)     # d : decimal, hex or label\n        // elsif ($op2 =~ /\\(([\\w\\+\\-]+)\\)/) { # ラベルも含まれるので \\d ではなく \\w\n        //   $opcode += 5;\n        //   $operand = parse_expression($1);\n        // }\n        else {\n            this.log.error(\"Invalid operand '\" + op1 + \"/\" + op2 + \"'\");\n            return { error: true };\n        }\n        return res;\n    };\n    /**\n     * EQU の処理 (10 進数変換してラベル表 _labels に追加)\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processEqu = function (asmLine) {\n        if (!asmLine.label) {\n            this.log.error('Label not found for EQU');\n            return false;\n        }\n        if (!asmLine.op1) {\n            this.log.error('Expected 1 operand for EQU');\n            return false;\n        }\n        if (asmLine.op1.toUpperCase() === 'CA') {\n            // EQU のオペランドを CA (current address) にしたら,\n            // その EQU 疑似命令の存在する場所のアドレスが割り当てられる.\n            // アドレスのインクリメントは行わない\n            this._labels[asmLine.label] = this._currentAddr;\n        }\n        else {\n            var value = this.evalExpression(asmLine.op1);\n            this._labels[asmLine.label] = value;\n        }\n        // $option = {no_data => 1};   // 疑似命令行なのでアセンブリのみ出力\n        this.log.debug(this._labels);\n        return true;\n    };\n    /**\n     * LOC のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processLoc = function (asmLine) {\n        if (!asmLine.op1) {\n            this.log.error('Expected 1 operand for LOC');\n            return false;\n        }\n        var addr = this.evalExpression(asmLine.op1);\n        if (this.isNumber(addr)) {\n            this._locAddr = addr;\n        }\n        this.log.debug(\"LOC addr: \" + this._locAddr);\n        // TODO: 評価できない場合 (2pass)\n        return true;\n    };\n    /**\n     * DAT のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processDat = function (asmLine) {\n        if (!asmLine.op1) {\n            this.log.error('Expected 1 operand for DAT');\n            return false;\n        }\n        if (!this._locAddr) {\n            this.log.debug('LOC addr is not defined now. skip.');\n            asmLine.isSkipped = true;\n            return true;\n        }\n        var op1 = asmLine.op1.toUpperCase();\n        var value = this.evalExpression(op1);\n        if (!this.isNumber(value)) {\n            this.log.debug('Data cannot be evaluated now. skip.');\n            asmLine.isSkipped = true;\n            return true;\n        }\n        asmLine.addr = this._locAddr;\n        asmLine.opcode = value;\n        this._locAddr += this._addrUnitBytes;\n        return true;\n    };\n    /**\n     * PROG のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processProg = function (asmLine) {\n        this.log.error(\"'PROG' is not supported\");\n        return false;\n    };\n    /**\n     * LD のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processLd = function (asmLine) {\n        if (!asmLine.op1 || !asmLine.op2) {\n            this.log.error('Expected 2 operands for LOC');\n            return false;\n        }\n        var op1 = asmLine.op1.toUpperCase();\n        var op2 = asmLine.op2.toUpperCase();\n        // LD IX SP\n        if (op1 === 'IX' && op2 === 'SP') {\n            asmLine.opcode = 0x01;\n        }\n        // LD SP IX\n        else if (op1 === 'SP' && op2 === 'IX') {\n            asmLine.opcode = 0x03;\n        }\n        // LD SP d\n        else if (op1 === 'SP' && this.isNumber(op2)) {\n            asmLine.opcode = 0x02;\n            asmLine.operand = this.evalExpression(op2);\n        }\n        // その他の (規則的な割り当てになっている) 命令\n        else {\n            var res = this.getOpcodeOfAssignmentAndArithmeticInst(asmLine.mnemonic, asmLine.op1, asmLine.op2);\n            if (res.error) {\n                return false;\n            }\n            if (res.opcode != null) {\n                asmLine.opcode = res.opcode;\n            }\n            if (res.operand != null) {\n                asmLine.operand = res.operand;\n            }\n            // if ( res.isSkipped ) asmLine.isSkipped = res.isSkipped\n            return true;\n        }\n        return true;\n    };\n    /**\n     *  ST, SBC, ADC のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processStSbcAdc = function (asmLine) {\n        if (!asmLine.op1 || !asmLine.op2) {\n            this.log.error('Expected 2 operands for ${asmLine.mnemonic}');\n            return false;\n        }\n        var res = this.getOpcodeOfAssignmentAndArithmeticInst(asmLine.mnemonic, asmLine.op1, asmLine.op2);\n        if (res.error) {\n            return false;\n        }\n        if (res.opcode) {\n            asmLine.opcode = res.opcode;\n        }\n        if (res.operand) {\n            asmLine.operand = res.operand;\n        }\n        // if ( res.isSkipped ) asmLine.isSkipped = res.isSkipped\n        return true;\n    };\n    /**\n     * SUB のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processSub = function (asmLine) {\n        if (!asmLine.op1 || !asmLine.op2) {\n            this.log.error(\"Expected 2 operands for \" + asmLine.mnemonic);\n            return false;\n        }\n        var op1 = asmLine.op1.toUpperCase();\n        if (op1 === 'SP') {\n            asmLine.opcode = 0x07;\n            asmLine.operand = this.evalExpression(asmLine.op2);\n        }\n        else {\n            var res = this.getOpcodeOfAssignmentAndArithmeticInst(asmLine.mnemonic, asmLine.op1, asmLine.op2);\n            if (res.error) {\n                return false;\n            }\n            if (res.opcode) {\n                asmLine.opcode = res.opcode;\n            }\n            if (res.operand) {\n                asmLine.operand = res.operand;\n            }\n        }\n        return true;\n    };\n    /**\n     * ADD のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processAdd = function (asmLine) {\n        if (!asmLine.op1 || !asmLine.op2) {\n            this.log.error(\"Expected 2 operands for \" + asmLine.mnemonic);\n            return false;\n        }\n        var op1 = asmLine.op1.toUpperCase();\n        if (op1 === 'SP') {\n            asmLine.opcode = 0x06;\n            asmLine.operand = this.evalExpression(asmLine.op2);\n        }\n        else {\n            var res = this.getOpcodeOfAssignmentAndArithmeticInst(asmLine.mnemonic, asmLine.op1, asmLine.op2);\n            if (res.error) {\n                return false;\n            }\n            if (res.opcode) {\n                asmLine.opcode = res.opcode;\n            }\n            if (res.operand) {\n                asmLine.operand = res.operand;\n            }\n        }\n        return true;\n    };\n    /**\n     *  のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processEorOrAndCmp = function (asmLine) {\n        this.log.error('Not implemented');\n        return false;\n    };\n    /**\n     *  のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processB = function (asmLine) {\n        if (!asmLine.op1) {\n            this.log.error(\"Expected 1 operand for \" + asmLine.mnemonic);\n            return false;\n        }\n        var mnemonic = asmLine.mnemonic;\n        if (mnemonic === 'BA') {\n            asmLine.opcode = 0x30;\n        }\n        else if (mnemonic === 'BVF') {\n            asmLine.opcode = 0x38;\n        }\n        else if (mnemonic === 'BNZ') {\n            asmLine.opcode = 0x31;\n        }\n        else if (mnemonic === 'BZP') {\n            asmLine.opcode = 0x32;\n        }\n        else if (mnemonic === 'BP') {\n            asmLine.opcode = 0x33;\n        }\n        else if (mnemonic === 'BNI') {\n            asmLine.opcode = 0x34;\n        }\n        else if (mnemonic === 'BNC') {\n            asmLine.opcode = 0x35;\n        }\n        else if (mnemonic === 'BGE') {\n            asmLine.opcode = 0x36;\n        }\n        else if (mnemonic === 'BGT') {\n            asmLine.opcode = 0x37;\n        }\n        else if (mnemonic === 'BZN') {\n            asmLine.opcode = 0x3B;\n        }\n        else if (mnemonic === 'BNO') {\n            asmLine.opcode = 0x3C;\n        }\n        else if (mnemonic === 'BZ') {\n            asmLine.opcode = 0x39;\n        }\n        else if (mnemonic === 'BN') {\n            asmLine.opcode = 0x3A;\n        }\n        else if (mnemonic === 'BC') {\n            asmLine.opcode = 0x3D;\n        }\n        else if (mnemonic === 'BLT') {\n            asmLine.opcode = 0x3E;\n        }\n        else if (mnemonic === 'BLE') {\n            asmLine.opcode = 0x3F;\n        }\n        else {\n            this.log.error(\"Invalid mnemonic '\" + mnemonic + \"'\");\n            return false;\n        }\n        asmLine.operand = this.evalExpression(asmLine.op1);\n        return true;\n    };\n    /**\n     *  のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processNop = function (asmLine) {\n        this.log.error('Not implemented');\n        return false;\n    };\n    /**\n     *  のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processHlt = function (asmLine) {\n        asmLine.opcode = 0x0F;\n        return true;\n    };\n    /**\n     *  のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processRcf = function (asmLine) {\n        this.log.error('not implemented');\n        return false;\n    };\n    /**\n     *  のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processScf = function (asmLine) {\n        this.log.error('not implemented');\n        return false;\n    };\n    /**\n     *  のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processEnd = function (asmLine) {\n        this._isEnded = true;\n        return true;\n    };\n    /**\n     *  のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processInc = function (asmLine) {\n        this.log.error('not implemented');\n        return false;\n    };\n    /**\n     *  のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processDec = function (asmLine) {\n        this.log.error('not implemented');\n        return false;\n    };\n    /**\n     *  のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processPsh = function (asmLine) {\n        this.log.error('not implemented');\n        return false;\n    };\n    /**\n     *  のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processPop = function (asmLine) {\n        this.log.error('not implemented');\n        return false;\n    };\n    /**\n     *  のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processCal = function (asmLine) {\n        this.log.error('not implemented');\n        return false;\n    };\n    /**\n     *  のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processRet = function (asmLine) {\n        this.log.error('not implemented');\n        return false;\n    };\n    /**\n     *  のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processSrRl = function (asmLine) {\n        this.log.error('not implemented');\n        return false;\n    };\n    /**\n     *  のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processOut = function (asmLine) {\n        this.log.error('not implemented');\n        return false;\n    };\n    /**\n     *  のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processIn = function (asmLine) {\n        this.log.error('not implemented');\n        return false;\n    };\n    /**\n     *  のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.processSt = function (asmLine) {\n        this.log.error('not implemented');\n        return false;\n    };\n    /**\n     * バイナリ表現のプログラムデータの生成 (内部形式から出力用形式に整形)\n     * @returns 成否 (true or false)\n     */\n    Kueasm.prototype.generate = function () {\n        var lines = [];\n        for (var _i = 0, _a = this._asm; _i < _a.length; _i++) {\n            var asmLine = _a[_i];\n            var addr = asmLine.addr != null ? (this.dec2hex(asmLine.addr, '') + ':') : '';\n            var opcode = asmLine.opcode != null ? this.dec2hex(asmLine.opcode, '') : '';\n            var operand = asmLine.operand != null ? this.dec2hex(asmLine.operand, '') : '';\n            var comment = asmLine.raw != '' ? \" \" + asmLine.raw : '';\n            lines.push(this._binary = (addr + \" \" + opcode + \" \" + operand).padEnd(17, ' ') + (\"#\" + comment));\n            this.log.debug(this._binary);\n        }\n        this._binary = lines.join('\\n') + '\\n';\n        return true;\n    };\n    return Kueasm;\n}());\n/* harmony default export */ __webpack_exports__[\"default\"] = (Kueasm);\n\n\n//# sourceURL=webpack:///./lib/kueasm.ts?");

/***/ }),

/***/ "./lib/logger.ts":
/*!***********************!*\
  !*** ./lib/logger.ts ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// import log4js from 'log4js'\n// const log4jsLogger = log4js.getLogger()\n// export default class KueasmLogger {\n//   private kueasm: any\n//   constructor(kueasm: Kueasm, logLevel: string) {\n//     this.kueasm = kueasm\n//     log4jsLogger.level = 'debug'\n//     if ( logLevel ) { log4jsLogger.level = logLevel }\n//   }\n//   public debug = (msg: any) => log4jsLogger.debug(msg, ` (l.${this.kueasm._currentLineNumber})`)\n//   public info  = (msg: any) => log4jsLogger.info (msg, ` (l.${this.kueasm._currentLineNumber})`)\n//   public warn  = (msg: any) => log4jsLogger.warn (msg, ` (l.${this.kueasm._currentLineNumber})`)\n//   public error = (msg: any) => log4jsLogger.error(msg, ` (l.${this.kueasm._currentLineNumber})`)\n// }\nvar KueasmLogger = /** @class */ (function () {\n    function KueasmLogger(kueasm, logLevel) {\n        this.debug = function (msg) { eval(\"logger.debug(msg, ' (l.'+this.kueasm._currentLineNumber+')')\"); };\n        this.info = function (msg) { eval(\"logger.info(msg,  ' (l.'+this.kueasm._currentLineNumber+')')\"); };\n        this.warn = function (msg) { eval(\"logger.warn(msg,  ' (l.'+this.kueasm._currentLineNumber+')')\"); };\n        this.error = function (msg) { eval(\"logger.error(msg, ' (l.'+this.kueasm._currentLineNumber+')')\"); };\n        this.kueasm = kueasm;\n    }\n    return KueasmLogger;\n}());\n/* harmony default export */ __webpack_exports__[\"default\"] = (KueasmLogger);\n\n\n//# sourceURL=webpack:///./lib/logger.ts?");

/***/ }),

/***/ "./src/web.ts":
/*!********************!*\
  !*** ./src/web.ts ***!
  \********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_kueasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/kueasm */ \"./lib/kueasm.ts\");\n\n// シミュレータ (kuesim.js) のロガーを使う\nvar mylogger = {\n    debug: function (msg) { return eval(\"logger.debug(\\\"\" + msg + \"\\\")\"); },\n    info: function (msg) { return eval(\"logger.info(\\\"\" + msg + \"\\\")\"); },\n    warn: function (msg) { return eval(\"logger.warn(\\\"\" + msg + \"\\\")\"); },\n    error: function (msg) { return eval(\"logger.error(\\\"\" + msg + \"\\\")\"); },\n};\nfunction assemble() {\n    var asm = $('#input-assembly').val();\n    if (asm == null) {\n        mylogger.error('internal error: failed to get instructions');\n        return;\n    }\n    var bin = (new _lib_kueasm__WEBPACK_IMPORTED_MODULE_0__[\"default\"](asm, 'kuechip3', 'debug')).exec();\n    if (!bin) {\n        // logger.log.error('failed to assemble')\n        return;\n    }\n    console.log(bin);\n    $('#output-binary').val(bin);\n}\n// アセンブルボタン (ts 側のコードを叩くのでこちらでイベントを設定しておく)\n$('#btn-assemble').on('click', assemble);\n\n\n//# sourceURL=webpack:///./src/web.ts?");

/***/ })

/******/ });