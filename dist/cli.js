#!/usr/bin/env node

/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/cli.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/instruction.ts":
/*!****************************!*\
  !*** ./lib/instruction.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst parser_1 = __importDefault(__webpack_require__(/*! @/lib/parser */ \"./lib/parser.ts\"));\nconst util_1 = __importDefault(__webpack_require__(/*! @/lib/util */ \"./lib/util.ts\"));\nconst logger_1 = __importDefault(__webpack_require__(/*! @envlib/logger */ \"./lib/node/logger.ts\"));\nconst MNEMONIC_MAP = {\n    LD: 0x60, ST: 0x70, SBC: 0x80, ADC: 0x90, SUB: 0xA0,\n    ADD: 0xB0, EOR: 0xC0, OR: 0xD0, AND: 0xE0, CMP: 0xF0,\n};\nclass Instruction {\n    /**\n     * @param content - アセンブリ命令 (1行) の内容\n     */\n    constructor(content) {\n        this._raw = content;\n        this.parse();\n    }\n    // getter\n    raw() { return this._raw; }\n    label() { return this._label; }\n    mnemonic() { return this._mnemonic; }\n    op1() { return this._op1; }\n    // getter/setter\n    previousLineLabel(value) {\n        if (value == null) {\n            return this._previousLineLabel;\n        } // getter\n        else {\n            this._previousLineLabel = value;\n        } // setter\n    }\n    /**\n     * 命令行 (ニーモニックのある行) かチェックする\n     * @returns ある: true, ない: false\n     */\n    hasMnemonic() {\n        return (this._mnemonic != null);\n    }\n    /**\n     * アセンブリ命令にオペランドが 1 つあるかどうかをチェックする\n     * @returns ある: true, ない: false\n     */\n    hasOneOperand() {\n        return (this._op1 != null);\n    }\n    /**\n     * アセンブリ命令にオペランドが 2 つあるかどうかをチェックする\n     * @returns ある: true, ない: false\n     */\n    hasTwoOperands() {\n        return (this._op1 !== null && this._op2 != null);\n    }\n    /**\n     * パースして各トークンを記録\n     */\n    parse() {\n        const result = (new parser_1.default(this._raw)).parse();\n        this._label = result.label ? result.label.toUpperCase() : undefined;\n        this._mnemonic = result.mnemonic ? result.mnemonic.toUpperCase() : undefined;\n        this._op1 = result.op1 ? result.op1.toUpperCase() : undefined;\n        this._op2 = result.op2 ? result.op2.toUpperCase() : undefined;\n        this._comment = result.comment ? result.comment.toUpperCase() : undefined;\n    }\n    /**\n     * アセンブルしてオペコード/オペランドのフィールドにセットする.\n     * ラベルで評価できないなら _isSkipped をセットする.\n     * @param params - パラメータのオブジェクト\n     * @returns アドレスのインクリメントサイズオブジェクト\n     */\n    assemble(params) {\n        const result = { curAddrInc: 0, locAddrInc: 0 };\n        const mnemonic = this.mnemonic();\n        if (mnemonic == null) {\n            throw util_1.default.error(`internal error: calling to assemble() of 'Instruction' object without mnemonic.`);\n        }\n        if (mnemonic.match(/^EQU$/)) { /* do nothing */ }\n        else if (mnemonic.match(/^LOC$/)) { /* do nothing */ }\n        else if (mnemonic.match(/^DAT$/)) {\n            this.assembleDat(params);\n        }\n        else if (mnemonic.match(/^PROG$/)) {\n            this.assembleProg(params);\n        }\n        else if (mnemonic.match(/^LD$/)) {\n            this.assembleLd(params);\n        }\n        else if (mnemonic.match(/^(ST|SBC|ADC)$/)) {\n            this.assembleStSbcAdc(params);\n        }\n        else if (mnemonic.match(/^SUB$/)) {\n            this.assembleSub(params);\n        }\n        else if (mnemonic.match(/^ADD$/)) {\n            this.assembleAdd(params);\n        }\n        else if (mnemonic.match(/^(EOR|OR|AND|CMP)$/)) {\n            this.assembleEorOrAndCmp(params);\n        }\n        else if (mnemonic.match(/^B/)) {\n            this.assembleB(params);\n        }\n        else if (mnemonic.match(/^NOP$/)) {\n            this.assembleNop(params);\n        }\n        else if (mnemonic.match(/^HLT$/)) {\n            this.assembleHlt(params);\n        }\n        else if (mnemonic.match(/^RCF$/)) {\n            this.assembleRcf(params);\n        }\n        else if (mnemonic.match(/^SCF$/)) {\n            this.assembleScf(params);\n        }\n        else if (mnemonic.match(/^END$/)) { /* do nothing */ }\n        else if (mnemonic.match(/^INC$/)) {\n            this.assembleInc(params);\n        }\n        else if (mnemonic.match(/^DEC$/)) {\n            this.assembleDec(params);\n        }\n        else if (mnemonic.match(/^PSH$/)) {\n            this.assemblePsh(params);\n        }\n        else if (mnemonic.match(/^POP$/)) {\n            this.assemblePop(params);\n        }\n        else if (mnemonic.match(/^CAL$/)) {\n            this.assembleCal(params);\n        }\n        else if (mnemonic.match(/^RET$/)) {\n            this.assembleRet(params);\n        }\n        else if (mnemonic.match(/^[SR][RL][AL]$/)) {\n            this.assembleShiftRotate(params);\n        }\n        else if (mnemonic.match(/^OUT$/)) {\n            this.assembleOut(params);\n        }\n        else if (mnemonic.match(/^IN$/)) {\n            this.assembleIn(params);\n        }\n        else {\n            throw util_1.default.error(`Invalid mnemonic '${this.mnemonic()}.`);\n        }\n        if (this.mnemonic() === 'DAT') {\n            result.locAddrInc++;\n        }\n        // DAT 命令以外の順番にアドレスを振る命令の場合\n        else {\n            if (params.onlyAddrAlloc) {\n                this._addr = params.curAddr; // 配置アドレスを確定\n            }\n            if (this._requireAddrWidth == null) {\n                throw util_1.default.error(`internal error: this._requireAddrWidth is not defined`);\n            }\n            // 次の配置アドレスを決定\n            result.curAddrInc++; // アドレスインクリメント回数を増加\n            if (this._operand != null) {\n                result.curAddrInc++; // アドレスインクリメント回数を増加\n            }\n            result.curAddrInc = this._requireAddrWidth;\n            logger_1.default.debug(`Increase addr ${result.curAddrInc} unit(s).`);\n        }\n        return result;\n    }\n    /**\n     * 代入演算と算術演算のオペコードを取得 (規則配列のもの)\n     * @param params - assemble() された時のパラメータ\n     * @returns {opcode?: number, operand?: number | string}\n     */\n    getOpcodeOfAssignmentAndArithmeticInst(params) {\n        if (this.mnemonic() == null) {\n            throw util_1.default.error(`internal error: calling getOpcodeOfAssignmentAndArithmeticInst() of 'Instruction' object without mnemonic.`);\n        }\n        if (!this.hasTwoOperands()) {\n            throw util_1.default.error(`Expected 2 operands for ${this.mnemonic()}`);\n        }\n        // チェック済みなので強制的に string として OK\n        const mnemonic = this._mnemonic;\n        const op1 = this._op1;\n        const op2 = this._op2;\n        const baseOpcode = MNEMONIC_MAP[mnemonic]; // 命令表の行を決定\n        if (baseOpcode == null) {\n            throw util_1.default.error(`Internal error: invalid mnemonic ${mnemonic}`);\n        }\n        const res = {};\n        // op1\n        if (op1 === 'ACC') {\n            res.opcode = baseOpcode + 0;\n        }\n        else if (op1 === 'IX') {\n            res.opcode = baseOpcode + 8;\n        }\n        else {\n            throw util_1.default.error(`Invalid operand '${op1}' for ${mnemonic}`);\n        }\n        // op2 == ACC\n        if (op2 === 'ACC') {\n            if (mnemonic.match(/^ST/)) {\n                throw util_1.default.error(`Invalid operand '${op2}' of 'ST' (use 'LD' to set registers)`);\n            }\n            if (params.onlyAddrAlloc) {\n                return { requireAddrWidth: 1 };\n            }\n            res.opcode += 0;\n        }\n        // op2 == IX\n        else if (op2 === 'IX') {\n            if (mnemonic.match(/^ST/)) {\n                throw util_1.default.error(`Invalid operand '${op2}' of 'ST' (use 'LD' to set registers)`);\n            }\n            if (params.onlyAddrAlloc) {\n                return { requireAddrWidth: 1 };\n            }\n            res.opcode += 1;\n        }\n        // op2 == d (ラベルを含む)\n        else if (op2.match(/^([A-Z0-9_\\+\\-\\*\\/]+)$/i)) {\n            if (mnemonic.match(/^ST/)) {\n                throw util_1.default.error(`Invalid operand '${op2}' of 'ST' (use 'LD' to set registers)`);\n            }\n            if (params.onlyAddrAlloc) {\n                return { requireAddrWidth: 2 };\n            }\n            res.opcode += 2;\n            res.operand = util_1.default.evalExpression(op2, params.labels);\n            if (!util_1.default.isNumber(res.operand)) {\n                logger_1.default.debug(`Operand ${res.operand} cannot be evaluated now. skip.`);\n            }\n        }\n        // op2 = [sp+d]\n        else if (op2.match(/\\[SP(\\+.+)?\\]$/i)) {\n            if (params.onlyAddrAlloc) {\n                return { requireAddrWidth: 2 };\n            }\n            res.opcode += 3;\n            const offset = RegExp.$1;\n            if (offset != null && offset.trim().length > 0) {\n                res.operand = util_1.default.evalExpression(offset, params.labels);\n            }\n            else {\n                res.operand = 0;\n            }\n        }\n        // op2 = [IX+d] / [IX]\n        else if (op2.match(/^\\[IX(\\+.+)?\\]$/i)) {\n            if (params.onlyAddrAlloc) {\n                return { requireAddrWidth: 2 };\n            }\n            res.opcode += 6;\n            const offset = RegExp.$1;\n            if (offset != null && offset.trim().length > 0) {\n                res.operand = util_1.default.evalExpression(offset, params.labels);\n            }\n            else {\n                res.operand = 0;\n            }\n        }\n        // op2 = [d]                         # d : decimal, hex or label\n        else if (op2.match(/^\\[([A-Z0-9_\\+\\-\\*\\/]+)\\]$/i)) {\n            if (params.onlyAddrAlloc) {\n                return { requireAddrWidth: 2 };\n            }\n            res.opcode += 4;\n            res.operand = util_1.default.evalExpression(op2.replace(/[\\[\\]]/g, ''), params.labels);\n            if (!util_1.default.isNumber(res.operand)) {\n                logger_1.default.debug(`Operand ${res.operand} cannot be evaluated now. skip.`);\n            }\n        }\n        // op2 = (IX+d) / (IX) (only for kuechip2)\n        else if (op2.match(/^\\(IX(\\+.+)?\\)$/i)) {\n            if (params.onlyAddrAlloc) {\n                return { requireAddrWidth: 2 };\n            }\n            res.opcode += 7;\n            const offset = RegExp.$1;\n            if (offset != null && offset.trim().length > 0) {\n                res.operand = util_1.default.evalExpression(offset, params.labels);\n            }\n            else {\n                res.operand = 0;\n            }\n        }\n        // op2 = (d) (only for kuechip2)     # d : decimal, hex or label\n        else if (op2.match(/^\\((.*)\\)$/)) {\n            if (params.onlyAddrAlloc) {\n                return { requireAddrWidth: 2 };\n            }\n            res.opcode += 5;\n            const offset = RegExp.$1;\n            if (offset != null && offset.trim().length > 0) {\n                res.operand = util_1.default.evalExpression(offset, params.labels);\n            }\n            else {\n                res.operand = 0;\n            }\n        }\n        else {\n            throw util_1.default.error(`Invalid operand '${op1}/${op2}'`);\n        }\n        return res;\n    }\n    /**\n     * DAT のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     * @todo 分類としては疑似命令になるので kueasm.ts に移したい\n     */\n    assembleDat(params) {\n        if (params.onlyAddrAlloc) {\n            return;\n        }\n        // DAT の配置アドレス決定は 1st pass でラベルの値が決定してからでないとできない\n        // → 他の命令とは異なり 2nd pass で配置アドレスも決める\n        this._addr = params.locAddr;\n        if (!this.hasOneOperand()) {\n            throw util_1.default.error(`Expected 1 operand for ${this.mnemonic()}`);\n        }\n        if (params.locAddr == null) {\n            throw util_1.default.error('Address for LOC is not defined.');\n        }\n        const op1 = this._op1; // hasOneOperand でチェックしてるので string 扱いして OK\n        this._opcode = util_1.default.evalExpression(op1, params.labels);\n    }\n    /**\n     * PROG のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    assembleProg(params) {\n        throw util_1.default.error(`'PROG' is not supported`);\n    }\n    /**\n     * LD のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    assembleLd(params) {\n        if (!this.hasTwoOperands()) {\n            throw util_1.default.error(`Expected 2 operands for ${this._mnemonic}`);\n        }\n        const op1 = this._op1;\n        const op2 = this._op2;\n        // LD IX SP\n        if (op1 === 'IX' && op2 === 'SP') {\n            if (params.onlyAddrAlloc) {\n                this._requireAddrWidth = 1;\n                return;\n            }\n            this._opcode = 0x01;\n        }\n        // LD SP IX\n        else if (op1 === 'SP' && op2 === 'IX') {\n            if (params.onlyAddrAlloc) {\n                this._requireAddrWidth = 1;\n                return;\n            }\n            this._opcode = 0x03;\n        }\n        // LD SP d\n        else if (op1 === 'SP') {\n            if (params.onlyAddrAlloc) {\n                this._requireAddrWidth = 2;\n                return;\n            }\n            this._opcode = 0x02;\n            this._operand = util_1.default.evalExpression(op2, params.labels);\n        }\n        // その他の (規則的な割り当てになっている) 命令\n        else {\n            const res = this.getOpcodeOfAssignmentAndArithmeticInst(params);\n            if (params.onlyAddrAlloc) {\n                this._requireAddrWidth = res.requireAddrWidth;\n                return;\n            }\n            if (res.opcode != null) {\n                this._opcode = res.opcode;\n            }\n            if (res.operand != null) {\n                this._operand = res.operand;\n            }\n        }\n    }\n    /**\n     * ST/SBC/ADC のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    assembleStSbcAdc(params) {\n        if (!this.hasTwoOperands()) {\n            throw util_1.default.error(`Expected 2 operands for ${this._mnemonic}`);\n        }\n        const res = this.getOpcodeOfAssignmentAndArithmeticInst(params);\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = res.requireAddrWidth;\n            return;\n        }\n        if (res.opcode != null) {\n            this._opcode = res.opcode;\n        }\n        if (res.operand != null) {\n            this._operand = res.operand;\n        }\n    }\n    /**\n     * SUB のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    assembleSub(params) {\n        if (!this.hasTwoOperands()) {\n            throw util_1.default.error(`Expected 2 operands for ${this._mnemonic}`);\n        }\n        const op1 = this._op1;\n        const op2 = this._op2;\n        if (op1 === 'SP') {\n            if (params.onlyAddrAlloc) {\n                this._requireAddrWidth = 2;\n                return;\n            }\n            this._opcode = 0x07;\n            this._operand = util_1.default.evalExpression(op2, params.labels);\n        }\n        else {\n            const res = this.getOpcodeOfAssignmentAndArithmeticInst(params);\n            if (params.onlyAddrAlloc) {\n                this._requireAddrWidth = res.requireAddrWidth;\n                return;\n            }\n            if (res.opcode != null) {\n                this._opcode = res.opcode;\n            }\n            if (res.operand != null) {\n                this._operand = res.operand;\n            }\n        }\n    }\n    /**\n     * ADD のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    assembleAdd(params) {\n        if (!this.hasTwoOperands()) {\n            throw util_1.default.error(`Expected 2 operands for ${this._mnemonic}`);\n        }\n        const op1 = this._op1;\n        const op2 = this._op2;\n        if (op1 === 'SP') {\n            if (params.onlyAddrAlloc) {\n                this._requireAddrWidth = 2;\n                return;\n            }\n            this._opcode = 0x06;\n            this._operand = util_1.default.evalExpression(op2, params.labels);\n        }\n        else {\n            const res = this.getOpcodeOfAssignmentAndArithmeticInst(params);\n            if (params.onlyAddrAlloc) {\n                this._requireAddrWidth = res.requireAddrWidth;\n                return;\n            }\n            if (res.opcode != null) {\n                this._opcode = res.opcode;\n            }\n            if (res.operand != null) {\n                this._operand = res.operand;\n            }\n        }\n    }\n    /**\n     * EOR/OR/CMP のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    assembleEorOrAndCmp(params) {\n        if (!this.hasTwoOperands()) {\n            throw util_1.default.error(`Expected 2 operands for ${this._mnemonic}`);\n        }\n        const op1 = this._op1;\n        const op2 = this._op2;\n        const res = this.getOpcodeOfAssignmentAndArithmeticInst(params);\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = res.requireAddrWidth;\n            return;\n        }\n        if (res.opcode != null) {\n            this._opcode = res.opcode;\n        }\n        if (res.operand != null) {\n            this._operand = res.operand;\n        }\n    }\n    /**\n     * B のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    assembleB(params) {\n        if (!this.hasOneOperand()) {\n            throw util_1.default.error(`Expected 1 operand for ${this._mnemonic}`);\n        }\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 2;\n            return;\n        }\n        if (this._mnemonic === 'BA') {\n            this._opcode = 0x30;\n        }\n        else if (this._mnemonic === 'BVF') {\n            this._opcode = 0x38;\n        }\n        else if (this._mnemonic === 'BNZ') {\n            this._opcode = 0x31;\n        }\n        else if (this._mnemonic === 'BZP') {\n            this._opcode = 0x32;\n        }\n        else if (this._mnemonic === 'BP') {\n            this._opcode = 0x33;\n        }\n        else if (this._mnemonic === 'BNI') {\n            this._opcode = 0x34;\n        }\n        else if (this._mnemonic === 'BNC') {\n            this._opcode = 0x35;\n        }\n        else if (this._mnemonic === 'BGE') {\n            this._opcode = 0x36;\n        }\n        else if (this._mnemonic === 'BGT') {\n            this._opcode = 0x37;\n        }\n        else if (this._mnemonic === 'BZN') {\n            this._opcode = 0x3B;\n        }\n        else if (this._mnemonic === 'BNO') {\n            this._opcode = 0x3C;\n        }\n        else if (this._mnemonic === 'BZ') {\n            this._opcode = 0x39;\n        }\n        else if (this._mnemonic === 'BN') {\n            this._opcode = 0x3A;\n        }\n        else if (this._mnemonic === 'BC') {\n            this._opcode = 0x3D;\n        }\n        else if (this._mnemonic === 'BLT') {\n            this._opcode = 0x3E;\n        }\n        else if (this._mnemonic === 'BLE') {\n            this._opcode = 0x3F;\n        }\n        else {\n            throw util_1.default.error(`Invalid mnemonic '${this._mnemonic}'`);\n        }\n        const op1 = this._op1;\n        this._operand = util_1.default.evalExpression(op1, params.labels);\n    }\n    /**\n     * NOP のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    assembleNop(params) {\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        this._opcode = 0x00;\n    }\n    /**\n     * HLT のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    assembleHlt(params) {\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        this._opcode = 0x0F;\n    }\n    /**\n     * RCF のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    assembleRcf(params) {\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        this._opcode = 0x20;\n    }\n    /**\n     * SCF のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    assembleScf(params) {\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        this._opcode = 0x28;\n    }\n    /**\n     * INC のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    assembleInc(params) {\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        if (this._op1 !== 'SP') {\n            throw util_1.default.error(`Invalid operand for ${this._mnemonic}: ${this._op1}`);\n        }\n        this._opcode = 0x04;\n    }\n    /**\n     * DEC のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    assembleDec(params) {\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        if (this._op1 !== 'SP') {\n            throw util_1.default.error(`Invalid operand for ${this._mnemonic}: ${this._op1}`);\n        }\n        this._opcode = 0x05;\n    }\n    /**\n     * PSH のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    assemblePsh(params) {\n        if (!this.hasOneOperand()) {\n            throw util_1.default.error(`Expected 1 operand for ${this._mnemonic}`);\n        }\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        if (this._op1 === 'ACC') {\n            this._opcode = 0x08;\n        }\n        else if (this._op1 === 'IX') {\n            this._opcode = 0x09;\n        }\n        else {\n            throw util_1.default.error(`invalid operand '${this._op1}' for ${this._mnemonic}`);\n        }\n    }\n    /**\n     * POP のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    assemblePop(params) {\n        if (!this.hasOneOperand()) {\n            throw util_1.default.error(`Expected 1 operand for ${this._mnemonic}`);\n        }\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        if (this._op1 === 'ACC') {\n            this._opcode = 0x0A;\n        }\n        else if (this._op1 === 'IX') {\n            this._opcode = 0x0B;\n        }\n        else {\n            throw util_1.default.error(`invalid operand '${this._op1}' for ${this._mnemonic}`);\n        }\n    }\n    /**\n     * CAL のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    assembleCal(params) {\n        if (!this.hasOneOperand()) {\n            throw util_1.default.error(`Expected 1 operand for ${this._mnemonic}`);\n        }\n        const op1 = this._op1;\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 2;\n            return;\n        }\n        this._opcode = 0x0C;\n        this._operand = util_1.default.evalExpression(op1, params.labels);\n    }\n    /**\n     * RET のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    assembleRet(params) {\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        this._opcode = 0x0D;\n    }\n    /**\n     * shift/rotate 系命令のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    assembleShiftRotate(params) {\n        if (!this.hasOneOperand()) {\n            throw util_1.default.error(`Expected 1 operand for ${this._mnemonic}`);\n        }\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        if (this._mnemonic === 'SRA') {\n            this._opcode = 0x40;\n        }\n        else if (this._mnemonic === 'SLA') {\n            this._opcode = 0x41;\n        }\n        else if (this._mnemonic === 'SRL') {\n            this._opcode = 0x42;\n        }\n        else if (this._mnemonic === 'SLL') {\n            this._opcode = 0x43;\n        }\n        else if (this._mnemonic === 'RRA') {\n            this._opcode = 0x44;\n        }\n        else if (this._mnemonic === 'RLA') {\n            this._opcode = 0x45;\n        }\n        else if (this._mnemonic === 'RRL') {\n            this._opcode = 0x46;\n        }\n        else if (this._mnemonic === 'RLL') {\n            this._opcode = 0x47;\n        }\n        else {\n            throw util_1.default.error(`Invalid mnemonic: ${this._mnemonic}`);\n        }\n        if (this._op1 === 'ACC') {\n            this._opcode += 0;\n        }\n        else if (this._op1 === 'IX') {\n            this._opcode += 8;\n        }\n        else {\n            throw util_1.default.error(`Invalid operand for ${this._mnemonic}: ${this._op1}`);\n        }\n    }\n    /**\n     * OUT のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    assembleOut(params) {\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        this._opcode = 0x10;\n    }\n    /**\n     * IN のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    assembleIn(params) {\n        if (params.onlyAddrAlloc) {\n            this._requireAddrWidth = 1;\n            return;\n        }\n        this._opcode = 0x1F;\n    }\n    /**\n     * ST のバイナリ表現を生成\n     * @param params - assemble() された時のパラメータ\n     */\n    assembleSt(params) {\n        logger_1.default.error('not implemented');\n    }\n    /**\n     * バイナリ表現のプログラムデータの生成 (内部形式から出力用形式に整形)\n     */\n    generate(addrUnitBytes) {\n        const addr = this._addr != null ? (util_1.default.dec2hex(this._addr, 2 * addrUnitBytes, '') + ':') : '';\n        const opcode = this._opcode != null ? (util_1.default.dec2hex(this._opcode, 2 * addrUnitBytes, '')) : '';\n        const operand = this._operand != null ? (util_1.default.dec2hex(this._operand, 2 * addrUnitBytes, '')) : '';\n        const comment = this._raw !== '' ? ` ${this._raw}` : '';\n        const binary = `${addr} ${opcode} ${operand}`.padEnd(17, ' ') + `#${comment}`;\n        logger_1.default.debug(binary);\n        return binary;\n    }\n}\nexports.default = Instruction;\n\n\n//# sourceURL=webpack:///./lib/instruction.ts?");

/***/ }),

/***/ "./lib/kueasm.ts":
/*!***********************!*\
  !*** ./lib/kueasm.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst logger_1 = __importDefault(__webpack_require__(/*! @envlib/logger */ \"./lib/node/logger.ts\"));\nconst instruction_1 = __importDefault(__webpack_require__(/*! @/lib/instruction */ \"./lib/instruction.ts\"));\nconst util_1 = __importDefault(__webpack_require__(/*! @/lib/util */ \"./lib/util.ts\"));\nclass Kueasm {\n    /**\n     * @param asm - アセンブリプログラムの内容\n     * @param mode - 'kuechip2' or 'kuechip3'\n     * @param logLebel - ログレベル (デフォルトは warn. debug や trace で詳細ログを確認可能)\n     */\n    constructor(asm, mode, logLevel = 'warn') {\n        this._labels = {}; // ラベルのアドレス (10進数) の対応\n        this._currentAddr = 0; // メモリデータを配置するアドレス\n        this._locAddr = undefined; // LOC (DAT で値を配置するアドレス) (for kue3)\n        this._isEnded = false; // end 命令が見つかった\n        this._mode = mode;\n        this._addrUnitBytes = (mode === 'kuechip3') ? 2 : 1;\n        logger_1.default.setLogLevel(logLevel);\n        logger_1.default.info('Start parse');\n        try {\n            this._instructions = asm.split('\\n').map((content) => new instruction_1.default(content));\n        }\n        catch {\n            logger_1.default.error('Failed to parse assembly program');\n            return;\n        }\n    }\n    /**\n     * アセンブルする\n     * @returns アセンブル結果 (バイナリ表現)\n     */\n    exec() {\n        logger_1.default.info('Start assemble');\n        // logger.trace(this._instructions)\n        if (!this.assemble()) {\n            logger_1.default.error('Failed to convert binary data');\n            return;\n        }\n        return this.generate();\n    }\n    /**\n     * バイナリ表現を生成して binary にセット\n     * @returns 成否 (true or false)\n     */\n    assemble() {\n        logger_1.default.debug('1st pass');\n        // logger.trace(this._instructions)          // デバッグ用に内部データをダンプ\n        for (let idx = 0; idx < this._instructions.length; idx++) {\n            logger_1.default.setLineNumber(idx + 1); // ロガーに現在の処理行をセット\n            // logger.trace(idx + 1)\n            // logger.trace(this._instructions)          // デバッグ用に内部データをダンプ\n            const inst = this._instructions[idx];\n            // 空行はスキップ\n            if (inst.raw().trim() === '') {\n                continue;\n            }\n            if (inst.mnemonic() != null && this._multilineLabel != null) {\n                inst.previousLineLabel(this._multilineLabel);\n                this._multilineLabel = undefined;\n            }\n            // 疑似命令の処理\n            // - EQU, その他のラベル行の処理\n            if (inst.mnemonic() === 'EQU') {\n                this.processEqu(inst);\n            }\n            else {\n                const label = inst.label() || inst.previousLineLabel();\n                if (label != null) {\n                    if (inst.mnemonic() != null) { // 命令がある行ならラベルに行番号をバインド\n                        this._labels[label] = this._currentAddr;\n                    }\n                    else { // 命令が無い行なら (次の命令行にバインドするために) 記録しておく\n                        this._multilineLabel = inst.label();\n                    }\n                }\n            }\n            // 命令行でなければ次へ\n            if (inst.mnemonic() == null\n                || inst.mnemonic() === 'EQU'\n                || inst.mnemonic() === 'LOC'\n                || inst.mnemonic() === 'END') {\n                continue;\n            }\n            logger_1.default.debug(`Process ${inst.mnemonic()}.`);\n            // バイナリ表現への変換\n            const { curAddrInc, locAddrInc } = inst.assemble({\n                labels: this._labels,\n                curAddr: this._currentAddr,\n                locAddr: this._locAddr,\n                onlyAddrAlloc: true,\n            });\n            // 次の命令配置アドレスを算出\n            this._currentAddr += (curAddrInc * this._addrUnitBytes);\n        }\n        logger_1.default.setLineNumber(undefined);\n        logger_1.default.debug('2nd pass');\n        for (let idx = 0; idx < this._instructions.length; idx++) {\n            const inst = this._instructions[idx];\n            logger_1.default.setLineNumber(idx + 1); // ロガーに現在の処理行をセット\n            // logger.trace(this.instructions)          // デバッグ用に内部データをダンプ\n            // 空行はスキップ\n            if (inst.raw().trim() === '') {\n                continue;\n            }\n            // - END の処理\n            if (inst.mnemonic() === 'END') {\n                break;\n            }\n            // - LOC の処理\n            if (inst.mnemonic() === 'LOC') {\n                this.processLoc(inst);\n            }\n            // 命令行でなければ次へ\n            if (inst.mnemonic() == null\n                || inst.mnemonic() === 'EQU'\n                || inst.mnemonic() === 'LOC') {\n                continue;\n            }\n            logger_1.default.debug(`Process ${inst.mnemonic()}.`);\n            // バイナリ表現への変換\n            const { curAddrInc, locAddrInc } = inst.assemble({\n                labels: this._labels,\n                curAddr: this._currentAddr,\n                locAddr: this._locAddr,\n                onlyAddrAlloc: false,\n            });\n            // 次の DAT の配置アドレスを算出\n            if (this._locAddr != null) {\n                this._locAddr += (locAddrInc * this._addrUnitBytes);\n            }\n        }\n        logger_1.default.setLineNumber(undefined);\n        return true;\n    }\n    /**\n     * EQU の処理 (10 進数変換してラベル表 labels に追加)\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    processEqu(inst) {\n        const label = inst.label() || inst.previousLineLabel();\n        const op1 = inst.op1();\n        if (label == null) {\n            logger_1.default.error('Label not found for EQU');\n            return false;\n        }\n        if (op1 == null) {\n            logger_1.default.error('Expected 1 operand for EQU');\n            return false;\n        }\n        if (op1.toUpperCase() === 'CA') {\n            // EQU のオペランドを CA (current address) にしたら,\n            // その EQU 疑似命令の存在する場所のアドレスが割り当てられる.\n            // アドレスのインクリメントは行わない\n            this._labels[label] = this._currentAddr;\n        }\n        else {\n            logger_1.default.debug(this._labels);\n            const value = util_1.default.evalExpression(op1, this._labels);\n            this._labels[label] = value;\n        }\n        logger_1.default.trace('labels: ' + JSON.stringify(this._labels));\n        return true;\n    }\n    /**\n     * LOC のバイナリ表現を生成\n     * @param asmLine - AsmLine オブジェクト\n     * @returns 成否 (true or false)\n     */\n    processLoc(inst) {\n        const op1 = inst.op1();\n        if (op1 == null) {\n            logger_1.default.error('Expected 1 operand for LOC');\n            return false;\n        }\n        const addr = util_1.default.evalExpression(op1, this._labels);\n        if (util_1.default.isNumber(addr)) {\n            this._locAddr = addr;\n        }\n        logger_1.default.trace(`LOC addr: ${this._locAddr}`);\n        return true;\n    }\n    /**\n     * 出力用バイナリを生成\n     * @returns 出力用バイナリ\n     */\n    generate() {\n        return this._instructions.map((inst) => inst.generate(this._addrUnitBytes)).join('\\n') + '\\n';\n    }\n}\nexports.default = Kueasm;\n\n\n//# sourceURL=webpack:///./lib/kueasm.ts?");

/***/ }),

/***/ "./lib/node/logger.ts":
/*!****************************!*\
  !*** ./lib/node/logger.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// ---------- CLI 用 ----------\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst log4js_1 = __importDefault(__webpack_require__(/*! log4js */ \"log4js\"));\nclass KueasmLoggerForNode {\n    constructor(logLevel = 'debug') {\n        this._log4jsLogger = log4js_1.default.getLogger();\n        this._log4jsLogger.level = logLevel;\n        // if ( logLevel ) { this.log4jsLogger.level = logLevel }\n        // else            { this.log4jsLogger.level = 'debug'  }\n    }\n    // setter\n    setLineNumber(lineNumber) {\n        this._lineNumber = lineNumber;\n    }\n    setLogLevel(logLevel) {\n        this._log4jsLogger.level = logLevel;\n    }\n    // log\n    trace(msg) { this._log4jsLogger.trace(msg, this.getLineNumberInfo()); }\n    debug(msg) { this._log4jsLogger.debug(msg, this.getLineNumberInfo()); }\n    info(msg) { this._log4jsLogger.info(msg, this.getLineNumberInfo()); }\n    warn(msg) { this._log4jsLogger.warn(msg, this.getLineNumberInfo()); }\n    error(msg) { this._log4jsLogger.error(msg, this.getLineNumberInfo()); }\n    getLineNumberInfo() {\n        return this._lineNumber == null ? '' : ` (l.${this._lineNumber})`;\n    }\n}\nexports.KueasmLoggerForNode = KueasmLoggerForNode;\n// ---------- 共通 ----------\nconst kueasmLogger = new KueasmLoggerForNode('warn');\nexports.default = kueasmLogger;\n\n\n//# sourceURL=webpack:///./lib/node/logger.ts?");

/***/ }),

/***/ "./lib/parser.ts":
/*!***********************!*\
  !*** ./lib/parser.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Parser {\n    /**\n     * アセンブリプログラムをパースする\n     * @param パースしたい命令 (1 行)\n     */\n    constructor(content) {\n        this._buf = content;\n    }\n    /**\n     * アセンブリプログラムをパースする\n     * @returns パース済み Instruction オブジェクト\n     * @throws パースに失敗\n     */\n    parse() {\n        if (!this.parseComment()) {\n            throw new Error('Parse error');\n        }\n        if (!this.parseLabel()) {\n            throw new Error('Parse error');\n        }\n        if (!this.parseMnemonicAndOperands()) {\n            throw new Error('Parse error');\n        }\n        return {\n            label: this._label,\n            mnemonic: this._mnemonic,\n            op1: this._op1,\n            op2: this._op2,\n            comment: this._comment,\n        };\n    }\n    /**\n     * コメントの処理する\n     * @returns 成功: true, 失敗: false\n     */\n    parseComment() {\n        // '#', ';;', '//' 以降をコメントとして扱う\n        const regexComment = /(#|;;|\\/\\/)(?<comment>.*)$/;\n        const match = this._buf.match(regexComment);\n        if (match) {\n            this._comment = match.groups.comment; // コメントを記録しておく\n            this._buf = this._buf.replace(regexComment, '').trim(); // コメントを除去\n        }\n        return true;\n    }\n    /**\n     * ラベルの処理する\n     * @returns 成功: true, 失敗: false\n     */\n    parseLabel() {\n        const regexLabel = /^(?<label>[A-za-z0-9_]+)\\s*:/;\n        const match = this._buf.match(regexLabel);\n        if (match) {\n            this._label = match.groups.label; // ラベルを記録しておく\n            this._buf = this._buf.replace(regexLabel, '').trim(); // ラベルを除去\n        }\n        return true;\n    }\n    /**\n     * ニーモニック, オペランドの処理\n     * @returns 成功: true, 失敗: false\n     */\n    parseMnemonicAndOperands() {\n        const tokens = this._buf.trim().split(/ +/);\n        // 最初の空白まで\n        if (tokens.length > 0) {\n            this._mnemonic = tokens.shift();\n        }\n        // 2 引数の場合は第 1 オペランドの後ろにコンマがあるかもしれない\n        if (tokens.length > 0) {\n            this._op1 = tokens.shift().replace(/,$/, '');\n        }\n        // 第 2 オペランドはスペースを含む可能性があるので残りを join\n        if (tokens.length > 0) {\n            this._op2 = tokens.join(' ');\n        }\n        return true;\n    }\n}\nexports.default = Parser;\n\n\n//# sourceURL=webpack:///./lib/parser.ts?");

/***/ }),

/***/ "./lib/util.ts":
/*!*********************!*\
  !*** ./lib/util.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst logger_1 = __importDefault(__webpack_require__(/*! @envlib/logger */ \"./lib/node/logger.ts\"));\nclass Util {\n    /**\n     * 数値かどうか (string も数字として判定)\n     * @param value - 判定したい値\n     * @returns boolean\n     */\n    isNumber(value) {\n        if (typeof value === 'number') {\n            return isFinite(value);\n        }\n        else if (typeof value === 'string') {\n            // string そのまま number として扱える場合\n            if (!isNaN(Number(value))) {\n                return true;\n            }\n            else if (/[0-9A-F]+H/i.exec(value)) {\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        return false;\n    }\n    /**\n     * パディング済み 16 進数文字列にして返す\n     * @param num - 数値 (10進数)\n     * @returns パディング済み 16 進数文字列\n     */\n    dec2hex(num, digit, prefix = '0x') {\n        if (num < 0) {\n            num = num & 0xFFFF;\n        } // 補数表現\n        return prefix + num.toString(16) // 16 進数表記\n            .substr(-digit, digit) // 桁数分切り出し (1 byte の時の補数表現用)\n            .toUpperCase() // 大文字\n            .padStart(digit, '0'); // 0 埋め\n    }\n    /**\n     * 式を評価 (四則演算, ラベルを含めることができる)\n     * @param expression - 評価したい式\n     * @returns パディング付き 16 進数表現\n     */\n    evalExpression(expression, labels) {\n        expression = expression.replace(/\\s+/g, '');\n        if (expression.match(/[\\+|\\-|\\*|\\/]/)) {\n            const terms = expression.split(/\\s*([\\+|\\-|\\*|\\/])\\s*/); // 各項を切り出す\n            const formattedTerms = [];\n            for (const term of terms) {\n                // 空白なら何もしない\n                if (term === '') { /* do nothing */ }\n                // 四則演算子はそのまま\n                else if (term === '+' || term === '-' || term === '*' || term === '/') {\n                    formattedTerms.push(term);\n                }\n                else {\n                    const value = this.evalExpression(term, labels);\n                    logger_1.default.trace(`Evaluate term: ${term} → ${value}`);\n                    formattedTerms.push(value);\n                }\n            }\n            // この時点でラベルの評価は完了している\n            // (一部が評価できない場合は再帰呼び出しした evalExpression で例外が投げられる)\n            const expressionValue = eval(formattedTerms.join(''));\n            logger_1.default.trace(`Evaluate expression: ${formattedTerms.join('')} → ${expressionValue}`);\n            return expressionValue;\n        }\n        // 16 進数\n        else if (expression.match(/^[0-9A-F]+H$/i)) {\n            return parseInt(expression.replace(/h/i, ''), 16);\n        }\n        // 10 進数\n        else if (util.isNumber(expression)) {\n            return parseInt(expression); // そのまま\n        }\n        // label\n        else if (labels[expression] != null) {\n            return labels[expression];\n        }\n        else {\n            throw util.error(`'${expression}' cannot evaluate.`);\n            // return `$(${expression})` // $(expression) にしておいて遅延評価する\n            // → 2pass にして遅延評価しないように変更\n        }\n    }\n    /**\n     * エラーメッセージを logger.error() してから Error オブジェクトを返す\n     * @param string - エラーメッセージ\n     * @returns Error オブジェクト\n     */\n    error(msg) {\n        logger_1.default.error(msg);\n        return new Error(msg);\n    }\n}\nexports.Util = Util;\nconst util = new Util();\nexports.default = util;\n\n\n//# sourceURL=webpack:///./lib/util.ts?");

/***/ }),

/***/ "./src/cli.ts":
/*!********************!*\
  !*** ./src/cli.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst command_line_args_1 = __importDefault(__webpack_require__(/*! command-line-args */ \"command-line-args\"));\nconst command_line_usage_1 = __importDefault(__webpack_require__(/*! command-line-usage */ \"command-line-usage\"));\nconst log4js_1 = __importDefault(__webpack_require__(/*! log4js */ \"log4js\"));\nconst kueasm_1 = __importDefault(__webpack_require__(/*! @/lib/kueasm */ \"./lib/kueasm.ts\"));\nconst logger = log4js_1.default.getLogger();\nlogger.level = 'warn';\nfunction main() {\n    const optionDefinition = [\n        { name: 'input', type: String, desc: '入力ファイル', defaultOption: true },\n        { name: 'output', alias: 'o', type: String, desc: '出力ファイル' },\n        { name: 'verbose', alias: 'v', type: Boolean, desc: '詳細なログを出力' },\n        { name: 'help', alias: 'h', type: Boolean, desc: 'ヘルプを表示' },\n    ];\n    const options = command_line_args_1.default(optionDefinition);\n    if (options.help || !options.input || options.command === 'help') {\n        const usage = command_line_usage_1.default([\n            {\n                header: 'Usage',\n                content: 'kueasm <input> -o <output>'\n            },\n            {\n                header: 'Options',\n                optionList: optionDefinition\n            }\n        ]);\n        console.log(usage);\n        process.exit(0);\n    }\n    if (options.verbose) {\n        logger.level = 'debug';\n    }\n    const inFilePath = options.input;\n    if (!inFilePath) {\n        logger.error('no input file');\n    }\n    const outFilePath = options.output || inFilePath.replace(/^(.*\\/)?([^\\/]+?)(\\.asm)?$/, '$2.bin');\n    logger.info(`input:  ${inFilePath}`);\n    logger.info(`output: ${outFilePath}`);\n    const asm = fs_1.default.readFileSync(inFilePath).toString();\n    const bin = (new kueasm_1.default(asm, 'kuechip3', logger.level)).exec();\n    if (!bin) {\n        process.exit(1);\n    }\n    fs_1.default.writeFileSync(outFilePath, bin);\n}\nmain();\n\n\n//# sourceURL=webpack:///./src/cli.ts?");

/***/ }),

/***/ "command-line-args":
/*!************************************!*\
  !*** external "command-line-args" ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"command-line-args\");\n\n//# sourceURL=webpack:///external_%22command-line-args%22?");

/***/ }),

/***/ "command-line-usage":
/*!*************************************!*\
  !*** external "command-line-usage" ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"command-line-usage\");\n\n//# sourceURL=webpack:///external_%22command-line-usage%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ }),

/***/ "log4js":
/*!*************************!*\
  !*** external "log4js" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"log4js\");\n\n//# sourceURL=webpack:///external_%22log4js%22?");

/***/ })

/******/ });